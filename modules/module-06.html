<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Module 6 - RESTful APIs: Building Backend Services with Express.js and Next.js">
    <title>Module 6: RESTful APIs | Advanced Web Development</title>
    <link rel="stylesheet" href="../css/slides.css">
    <style>
        /* Dark theme components */
        .dark-container {
            background: linear-gradient(135deg, #1a2332 0%, #2d3748 100%);
            border-radius: 12px;
            padding: 2rem;
            border-left: 4px solid;
            border-image: linear-gradient(180deg, #06b6d4, #f97316, #22c55e) 1;
        }
        .dark-container h2 { color: #fff; margin: 0 0 0.5rem 0; font-size: 1.8rem; }
        .dark-container .subtitle { color: #94a3b8; margin-bottom: 1.5rem; }
        .dark-container h3 { color: #06b6d4; margin-top: 1rem; }
        .dark-container ul { color: #94a3b8; }
        .dark-container li { margin-bottom: 0.5rem; }
        .dark-container strong { color: #fff; }
        .dark-container p { color: #94a3b8; }
        .dark-container code { background: #2d3a4d; color: #06b6d4; padding: 0.2rem 0.4rem; border-radius: 4px; }

        .dark-two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
        .dark-three-column { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; }
        .dark-four-column { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; }

        .dark-card {
            background: #2d3a4d;
            border-radius: 8px;
            padding: 1rem;
            border-left: 3px solid #06b6d4;
        }
        .dark-card h4 { color: #fff; margin: 0 0 0.5rem 0; }
        .dark-card p { color: #94a3b8; font-size: 0.9rem; margin: 0; }
        .dark-card.warning { border-left-color: #facc15; }
        .dark-card.danger { border-left-color: #f87171; }
        .dark-card.success { border-left-color: #4ade80; }
        .dark-card.info { border-left-color: #22d3ee; }

        .dark-table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        .dark-table th { background: #3d4a5d; color: #fff; padding: 0.75rem 1rem; text-align: left; }
        .dark-table td { background: #2d3a4d; color: #94a3b8; padding: 0.75rem 1rem; border-bottom: 1px solid #3d4a5d; }
        .dark-table code { background: #1a2332; color: #06b6d4; padding: 0.2rem 0.4rem; border-radius: 4px; }

        /* Method badges */
        .method-pill {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.85rem;
            margin-right: 0.5rem;
        }
        .method-pill.get { background: #4ade80; color: #1a1a1a; }
        .method-pill.post { background: #facc15; color: #1a1a1a; }
        .method-pill.put { background: #22d3ee; color: #1a1a1a; }
        .method-pill.delete { background: #f87171; color: #1a1a1a; }

        /* Status badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            margin: 0.25rem;
        }
        .status-badge.success { background: #166534; color: #4ade80; }
        .status-badge.created { background: #14532d; color: #86efac; }
        .status-badge.client-error { background: #7f1d1d; color: #fca5a5; }
        .status-badge.server-error { background: #581c87; color: #c4b5fd; }

        /* Flow diagram */
        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
        }
        .endpoint-box {
            background: #2d3a4d;
            border-radius: 12px;
            padding: 1.5rem 2rem;
            text-align: center;
            min-width: 140px;
            border: 2px solid transparent;
        }
        .endpoint-box.client-box { border-color: #22d3ee; }
        .endpoint-box.server-box { border-color: #f97316; }
        .endpoint-box.db-box { border-color: #a855f7; }
        .endpoint-box .label {
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        .endpoint-box.client-box .label { color: #22d3ee; }
        .endpoint-box.server-box .label { color: #f97316; }
        .endpoint-box.db-box .label { color: #a855f7; }
        .endpoint-box .title {
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .flow-arrow {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #94a3b8;
        }
        .flow-arrow .arrow { font-size: 1.5rem; }
        .flow-arrow .label { font-size: 0.7rem; margin-top: 0.25rem; }

        .big-number { font-size: 4rem; font-weight: bold; color: #06b6d4; line-height: 1; }
        .stat-label { color: #94a3b8; font-size: 1.1rem; margin-top: 0.5rem; }

        .code-block { background: #1a2332; border-radius: 8px; padding: 1rem; overflow-x: auto; }
        .code-block pre { margin: 0; color: #e2e8f0; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.9rem; line-height: 1.5; }
        .code-block .comment { color: #6b7280; }
        .code-block .keyword { color: #c084fc; }
        .code-block .string { color: #4ade80; }
        .code-block .function { color: #60a5fa; }
        .code-block .number { color: #f472b6; }
        .code-block .tag { color: #06b6d4; }
        .code-block .attr { color: #facc15; }

        .terminal-block {
            background: #0d1117;
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #c9d1d9;
            margin: 1rem 0;
        }
        .terminal-block .prompt { color: #7ee787; }
        .terminal-block .command { color: #fff; }
        .terminal-block .output { color: #8b949e; }

        .feature-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .feature-item { display: flex; align-items: flex-start; gap: 0.75rem; }
        .feature-icon { color: #06b6d4; font-size: 1.25rem; }
        .feature-text { color: #94a3b8; }
        .feature-text strong { color: #fff; display: block; margin-bottom: 0.25rem; }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            color: #1a2332;
            font-weight: bold;
            font-size: 1.2rem;
            border-radius: 50%;
            margin-right: 1rem;
        }

        /* Resource card styles */
        .resource-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1.5rem; }
        .resource-card {
            background: #2d3a4d;
            border-radius: 12px;
            padding: 1.5rem;
            text-decoration: none;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid #3d4a5d;
        }
        .resource-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        .resource-card h4 { color: #fff; margin: 0 0 0.5rem 0; }
        .resource-card p { color: #94a3b8; margin: 0; font-size: 0.9rem; }
        .resource-card .icon { font-size: 2rem; margin-bottom: 0.5rem; }

        /* URL examples */
        .url-example {
            background: #2d3a4d;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.95rem;
        }
        .url-example.good { border-left: 3px solid #4ade80; }
        .url-example.bad { border-left: 3px solid #f87171; text-decoration: line-through; color: #6b7280; }
        .url-example .base { color: #6b7280; }
        .url-example .path { color: #4ade80; }
        .url-example .param { color: #facc15; }

        /* JSON block */
        .json-block {
            background: #1a2332;
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        .json-block .key { color: #f472b6; }
        .json-block .string { color: #4ade80; }
        .json-block .number { color: #facc15; }
        .json-block .boolean { color: #60a5fa; }
        .json-block .punctuation { color: #94a3b8; }

        @media (max-width: 900px) {
            .dark-two-column, .dark-three-column { grid-template-columns: 1fr; }
            .dark-four-column { grid-template-columns: repeat(2, 1fr); }
            .feature-grid { grid-template-columns: 1fr; }
            .flow-diagram { flex-direction: column; }
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <div class="presentation">
        <!-- ========== Module Title ========== -->

        <!-- Slide 1: Title -->
        <section class="slide title-slide" data-narration="Welcome to Module 6, where we dive into one of the most important skills in modern web development: building RESTful APIs. In Module 5, you built a React frontend. Now you'll learn how to build the backend services that power those frontends. APIs are how applications communicate with each other - when your React app needs data, it asks an API. By the end of this module, you'll build the same Tasks API twice: once with Express.js, the most popular Node.js framework, and once with Next.js, which lets you add API routes to your React apps. This comparison will help you understand when to use each approach.">
            <h1>Module 6</h1>
            <p class="subtitle">RESTful APIs</p>
            <p class="meta">Building Backend Services</p>
        </section>

        <!-- Slide 2: Recommended Resources -->
        <section class="slide" id="resources" data-narration="Here are some excellent resources to supplement your learning. The MDN Web Docs HTTP guide provides comprehensive documentation on HTTP methods and status codes - it's the authoritative reference. The Express.js official documentation is well-written and includes many examples. For Next.js, the official Route Handlers documentation covers everything you need for the App Router. And Postman's Learning Center has interactive tutorials for API testing. These resources will help reinforce the concepts we cover and provide deeper dives when you need them.">
            <div class="dark-container">
                <h2>Recommended Resources</h2>
                <p class="subtitle">References to supplement your API development journey.</p>
                <div class="resource-grid">
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener" class="resource-card">
                        <div class="icon">ðŸ“–</div>
                        <h4>MDN HTTP Guide</h4>
                        <p>Comprehensive HTTP documentation - methods, status codes, headers</p>
                    </a>
                    <a href="https://expressjs.com/" target="_blank" rel="noopener" class="resource-card">
                        <div class="icon">ðŸš‚</div>
                        <h4>Express.js Docs</h4>
                        <p>Official Express documentation with examples and API reference</p>
                    </a>
                    <a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers" target="_blank" rel="noopener" class="resource-card">
                        <div class="icon">â–²</div>
                        <h4>Next.js Route Handlers</h4>
                        <p>Official docs for building APIs with Next.js App Router</p>
                    </a>
                    <a href="https://www.postman.com/postman/published-postman-templates/documentation/ae2ja6x/learn-by-api" target="_blank" rel="noopener" class="resource-card">
                        <div class="icon">ðŸ§ª</div>
                        <h4>Postman Learning</h4>
                        <p>Interactive tutorials for API testing and development</p>
                    </a>
                </div>
            </div>
        </section>

        <!-- ========== PART 1: Understanding APIs ========== -->

        <!-- Slide 3: Part 1 Title -->
        <section class="slide title-slide" id="part1" data-narration="Part 1 covers the fundamentals of APIs and REST. Before we write any code, we need to understand what we're building and why. You'll learn what an API is, what REST means, how HTTP methods map to database operations, and how to design clean URLs. We'll also introduce Postman, the tool you'll use to test your APIs. This foundation is essential - once you understand these concepts, the coding in Parts 2 and 3 will make much more sense.">
            <h1>Part 1</h1>
            <p class="subtitle">Understanding APIs</p>
        </section>

        <!-- Slide 4: Quick Recap from Module 2 -->
        <section class="slide" id="recap" data-narration="Let's quickly recap what you learned in Module 2 about how the web works. Remember the client-server model: your browser, the client, sends HTTP requests to a server, which processes them and sends back HTTP responses. Each request has a method like GET, a URL, and optional headers and body. Each response has a status code, headers, and a body with the actual content. This request-response cycle is the foundation of everything we'll build. APIs work exactly the same way - instead of returning HTML pages, they return data, usually in JSON format.">
            <div class="dark-container">
                <h2>Quick Recap: How the Web Works</h2>
                <p class="subtitle">Remember from Module 2 - the HTTP request/response cycle.</p>
                <div class="flow-diagram">
                    <div class="endpoint-box client-box">
                        <div class="label">CLIENT</div>
                        <div class="title">Browser</div>
                    </div>
                    <div class="flow-arrow">
                        <span class="arrow">â†’</span>
                        <span class="label">HTTP Request</span>
                    </div>
                    <div class="endpoint-box server-box">
                        <div class="label">SERVER</div>
                        <div class="title">Web Server</div>
                    </div>
                    <div class="flow-arrow">
                        <span class="arrow">â†’</span>
                        <span class="label">HTTP Response</span>
                    </div>
                    <div class="endpoint-box client-box">
                        <div class="label">CLIENT</div>
                        <div class="title">Browser</div>
                    </div>
                </div>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Request Contains</h4>
                        <p>Method (GET, POST...), URL, Headers, Body (optional)</p>
                    </div>
                    <div class="dark-card">
                        <h4>Response Contains</h4>
                        <p>Status Code (200, 404...), Headers, Body (HTML, JSON...)</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 5: What is an API? -->
        <section class="slide" id="what-is-api" data-narration="API stands for Application Programming Interface. Think of it as a contract between two pieces of software that defines how they can communicate. Here's an analogy: imagine a restaurant. You, the customer, don't go into the kitchen to make your food. Instead, you use a menu - that's the API. You place an order through the waiter, the kitchen prepares it, and you get your food back. You don't need to know how the kitchen works internally. APIs work the same way: your frontend app makes requests to defined endpoints, the server processes them, and returns data. The frontend doesn't need to know how the database works or how the server is implemented.">
            <div class="dark-container">
                <h2>What is an API?</h2>
                <p class="subtitle">Application Programming Interface - how software components communicate.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3>The Restaurant Analogy</h3>
                        <div class="dark-card" style="margin-top: 1rem;">
                            <h4>You (Client)</h4>
                            <p>Order food from the menu, receive your meal</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Menu (API)</h4>
                            <p>Defines what you can order and how</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Kitchen (Server)</h4>
                            <p>Prepares your order - you don't see how</p>
                        </div>
                    </div>
                    <div>
                        <h3>In Web Development</h3>
                        <div class="dark-card" style="margin-top: 1rem;">
                            <h4>React App (Client)</h4>
                            <p>Makes requests, displays received data</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Endpoints (API)</h4>
                            <p>Defines available operations and data formats</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Express/Next.js (Server)</h4>
                            <p>Processes requests, returns data</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 6: What is REST? -->
        <section class="slide" id="what-is-rest" data-narration="REST stands for REpresentational State Transfer. It's not a protocol or standard - it's an architectural style, a set of guidelines for designing web APIs. REST was defined by Roy Fielding in his PhD dissertation in 2000. The key idea is that everything is a resource - users, tasks, products - and each resource has a unique URL. You interact with resources using standard HTTP methods. REST is stateless, meaning each request contains all the information needed to process it - the server doesn't remember previous requests. This makes REST APIs simple, scalable, and cacheable. Most modern web APIs follow REST principles because they're intuitive and work well with HTTP.">
            <div class="dark-container">
                <h2>What is REST?</h2>
                <p class="subtitle">REpresentational State Transfer - an architectural style for web APIs.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Resources</h4>
                        <p>Everything is a resource (users, tasks, products) with a unique URL</p>
                    </div>
                    <div class="dark-card">
                        <h4>Stateless</h4>
                        <p>Each request contains all info needed - server doesn't remember you</p>
                    </div>
                    <div class="dark-card">
                        <h4>Uniform Interface</h4>
                        <p>Use standard HTTP methods (GET, POST, PUT, DELETE)</p>
                    </div>
                </div>
                <div class="dark-card info" style="margin-top: 1.5rem;">
                    <h4>Why REST?</h4>
                    <p>Simple, scalable, cacheable, and works naturally with HTTP. Most modern APIs follow REST principles.</p>
                </div>
            </div>
        </section>

        <!-- Slide 7: HTTP Methods = CRUD -->
        <section class="slide" id="http-methods" data-narration="REST APIs use HTTP methods to indicate what operation to perform. There's a direct mapping to CRUD operations - Create, Read, Update, Delete - the four basic operations for persistent storage. GET retrieves data without modifying anything - it's safe and idempotent, meaning you can call it multiple times with the same result. POST creates new resources. PUT updates existing resources by replacing them entirely. DELETE removes resources. Some APIs also use PATCH for partial updates, but we'll focus on these four. The key insight is that the HTTP method tells the server what to do, while the URL tells it which resource to act on.">
            <div class="dark-container">
                <h2>HTTP Methods = CRUD Operations</h2>
                <p class="subtitle">Each HTTP method maps to a database operation.</p>
                <table class="dark-table" style="margin-top: 1.5rem;">
                    <tr>
                        <th>Method</th>
                        <th>CRUD</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><span class="method-pill get">GET</span></td>
                        <td><strong style="color: #fff;">Read</strong></td>
                        <td>Retrieve data</td>
                        <td><code>GET /tasks</code></td>
                    </tr>
                    <tr>
                        <td><span class="method-pill post">POST</span></td>
                        <td><strong style="color: #fff;">Create</strong></td>
                        <td>Create new resource</td>
                        <td><code>POST /tasks</code></td>
                    </tr>
                    <tr>
                        <td><span class="method-pill put">PUT</span></td>
                        <td><strong style="color: #fff;">Update</strong></td>
                        <td>Update existing resource</td>
                        <td><code>PUT /tasks/123</code></td>
                    </tr>
                    <tr>
                        <td><span class="method-pill delete">DELETE</span></td>
                        <td><strong style="color: #fff;">Delete</strong></td>
                        <td>Remove resource</td>
                        <td><code>DELETE /tasks/123</code></td>
                    </tr>
                </table>
            </div>
        </section>

        <!-- Slide 8: Status Codes -->
        <section class="slide" id="status-codes" data-narration="HTTP status codes tell the client what happened with their request. They're grouped by the first digit: 2xx means success, 4xx means the client made an error, and 5xx means the server had an error. For APIs, you'll use these most often: 200 OK for successful GET requests, 201 Created when POST successfully creates something, 400 Bad Request when the client sends invalid data, 404 Not Found when the resource doesn't exist, and 500 Internal Server Error when something goes wrong on the server. Using the right status codes makes your API predictable and easier to debug. Don't just return 200 for everything - be specific about what happened.">
            <div class="dark-container">
                <h2>HTTP Status Codes</h2>
                <p class="subtitle">Tell clients what happened with their request.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3 style="color: #4ade80;">Success (2xx)</h3>
                        <div class="dark-card success" style="margin-top: 0.5rem;">
                            <h4><span class="status-badge success">200</span> OK</h4>
                            <p>Request succeeded - data returned</p>
                        </div>
                        <div class="dark-card success" style="margin-top: 0.5rem;">
                            <h4><span class="status-badge created">201</span> Created</h4>
                            <p>New resource created successfully</p>
                        </div>
                    </div>
                    <div>
                        <h3 style="color: #f87171;">Errors (4xx/5xx)</h3>
                        <div class="dark-card danger" style="margin-top: 0.5rem;">
                            <h4><span class="status-badge client-error">400</span> Bad Request</h4>
                            <p>Client sent invalid data</p>
                        </div>
                        <div class="dark-card danger" style="margin-top: 0.5rem;">
                            <h4><span class="status-badge client-error">404</span> Not Found</h4>
                            <p>Resource doesn't exist</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem; border-left-color: #a855f7;">
                            <h4><span class="status-badge server-error">500</span> Server Error</h4>
                            <p>Something went wrong on the server</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 9: RESTful URL Design -->
        <section class="slide" id="url-design" data-narration="Good URL design makes your API intuitive. The key rule is: use nouns, not verbs. The HTTP method already tells us the action, so the URL should identify the resource. For collections, use plural nouns: /tasks, /users, /products. For individual items, add the ID: /tasks/123. For nested resources, chain them: /users/456/tasks gets all tasks for user 456. Avoid verbs in URLs - /getTasks is wrong because GET already means 'get'. Keep URLs lowercase and use hyphens for multi-word resources like /user-profiles. These conventions make your API predictable - developers can guess endpoints without reading documentation.">
            <div class="dark-container">
                <h2>RESTful URL Design</h2>
                <p class="subtitle">Use nouns, not verbs. Let HTTP methods indicate the action.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3 style="color: #4ade80;">Good URLs</h3>
                        <div class="url-example good">
                            <span class="base">GET</span> <span class="path">/tasks</span>
                        </div>
                        <div class="url-example good">
                            <span class="base">GET</span> <span class="path">/tasks/</span><span class="param">123</span>
                        </div>
                        <div class="url-example good">
                            <span class="base">POST</span> <span class="path">/tasks</span>
                        </div>
                        <div class="url-example good">
                            <span class="base">DELETE</span> <span class="path">/tasks/</span><span class="param">123</span>
                        </div>
                    </div>
                    <div>
                        <h3 style="color: #f87171;">Bad URLs</h3>
                        <div class="url-example bad">
                            <span class="base">GET</span> /getTasks
                        </div>
                        <div class="url-example bad">
                            <span class="base">GET</span> /getTaskById/123
                        </div>
                        <div class="url-example bad">
                            <span class="base">POST</span> /createTask
                        </div>
                        <div class="url-example bad">
                            <span class="base">POST</span> /deleteTask/123
                        </div>
                    </div>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>Rules</h4>
                    <p>Plural nouns (<code>/tasks</code> not <code>/task</code>) | Lowercase | Hyphens for multi-word (<code>/user-profiles</code>)</p>
                </div>
            </div>
        </section>

        <!-- Slide 10: JSON Format -->
        <section class="slide" id="json" data-narration="JSON, JavaScript Object Notation, is the standard format for API data. It's human-readable and easy for JavaScript to parse. JSON supports strings in double quotes, numbers, booleans true and false, null, arrays in square brackets, and nested objects in curly braces. When you send data to an API with POST or PUT, you send JSON in the request body. When the API responds, it returns JSON. This example shows a task object with an id number, text string, completed boolean, and createdAt timestamp. Notice everything uses double quotes for property names - that's required in JSON, unlike JavaScript objects.">
            <div class="dark-container">
                <h2>JSON: The Language of APIs</h2>
                <p class="subtitle">JavaScript Object Notation - how APIs send and receive data.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3>Task Object Example</h3>
                        <div class="json-block" style="margin-top: 0.5rem;">
<pre><span class="punctuation">{</span>
  <span class="key">"id"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>
  <span class="key">"text"</span><span class="punctuation">:</span> <span class="string">"Learn REST APIs"</span><span class="punctuation">,</span>
  <span class="key">"completed"</span><span class="punctuation">:</span> <span class="boolean">false</span><span class="punctuation">,</span>
  <span class="key">"createdAt"</span><span class="punctuation">:</span> <span class="string">"2026-01-15"</span>
<span class="punctuation">}</span></pre>
                        </div>
                    </div>
                    <div>
                        <h3>Data Types</h3>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Strings</h4>
                            <p><code>"text"</code> - always double quotes</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Numbers</h4>
                            <p><code>42</code>, <code>3.14</code> - no quotes</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Booleans</h4>
                            <p><code>true</code>, <code>false</code> - lowercase</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>Arrays</h4>
                            <p><code>[1, 2, 3]</code> - square brackets</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 11: Introduction to Postman -->
        <section class="slide" id="postman" data-narration="Postman is the most popular tool for testing APIs. While you can test GET requests in a browser, you can't easily test POST, PUT, or DELETE - browsers just do GET when you enter a URL. Postman lets you make any type of HTTP request, set headers, include a JSON body, and see the full response. You can save requests into collections for reuse and even export them to share. Download Postman from postman.com - the free version has everything you need. We'll use it throughout this module to test every endpoint we build. It's an essential tool in any API developer's toolkit.">
            <div class="dark-container">
                <h2>Introduction to Postman</h2>
                <p class="subtitle">The essential tool for testing and developing APIs.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Why Postman?</h4>
                        <p>Browsers only do GET requests. Postman lets you test POST, PUT, DELETE with full control.</p>
                    </div>
                    <div class="dark-card">
                        <h4>Key Features</h4>
                        <p>Set HTTP methods, headers, JSON bodies. See full responses. Save to collections.</p>
                    </div>
                    <div class="dark-card">
                        <h4>Get Started</h4>
                        <p>Download free from <strong style="color: #06b6d4;">postman.com</strong>. Create account optional.</p>
                    </div>
                </div>
                <div class="dark-card info" style="margin-top: 1.5rem;">
                    <h4>What We'll Do</h4>
                    <p>Test every endpoint we build. Save requests to a "Tasks API" collection. Export for assignment submission.</p>
                </div>
            </div>
        </section>

        <!-- Slide 12: Part 1 Summary -->
        <section class="slide" id="part1-summary" data-narration="Let's recap Part 1. APIs are interfaces that let applications communicate, typically returning JSON data instead of HTML. REST is an architectural style based on resources, statelessness, and standard HTTP methods. HTTP methods map to CRUD: GET reads, POST creates, PUT updates, DELETE removes. Status codes communicate what happened: 2xx for success, 4xx for client errors, 5xx for server errors. Good URLs use nouns not verbs, with plural names for collections. JSON is the standard data format. And Postman is your tool for testing APIs. With these fundamentals solid, you're ready to build your first API in Part 2.">
            <div class="dark-container">
                <h2>Part 1 Summary</h2>
                <p class="subtitle">The foundations of RESTful API development.</p>
                <div class="feature-grid" style="margin-top: 1.5rem;">
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>APIs = Communication</strong>
                            Interfaces for apps to exchange data (usually JSON)
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>REST = Architecture</strong>
                            Resources, stateless, uniform HTTP interface
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>Methods = CRUD</strong>
                            GET/POST/PUT/DELETE map to Read/Create/Update/Delete
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>Status Codes = Results</strong>
                            200 OK, 201 Created, 400 Bad, 404 Not Found, 500 Error
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>URLs = Nouns</strong>
                            /tasks not /getTasks - method indicates action
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">âœ“</span>
                        <div class="feature-text">
                            <strong>Postman = Testing</strong>
                            Essential tool for testing all HTTP methods
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== PART 2: Express.js ========== -->

        <!-- Slide 13: Part 2 Title -->
        <section class="slide title-slide" id="part2" data-narration="Part 2 is where we get hands-on with Express.js, the most popular Node.js web framework. Express has been the go-to choice for Node.js APIs since 2010. It's minimal and unopinionated - it gives you the basics and lets you structure your app however you want. We'll build a complete Tasks API with all CRUD operations, store data in a JSON file, and test everything with Postman. By the end of Part 2, you'll have a working API and the skills to build your own. Let's start coding!">
            <h1>Part 2</h1>
            <p class="subtitle">Building APIs with Express.js</p>
        </section>

        <!-- Slide 14: What is Express.js? -->
        <section class="slide" id="what-is-express" data-narration="Express.js is a minimal, flexible Node.js web framework. It provides a thin layer on top of Node's built-in HTTP module, making it much easier to handle routes, middleware, and requests. Express follows a 'batteries not included' philosophy - it gives you the essentials and lets you add what you need. This makes it lightweight and fast, but means you'll install additional packages for things like parsing JSON bodies or enabling CORS. Express has been downloaded billions of times and powers APIs at companies like IBM, Uber, and Twitter. It's the foundation you'll find in most Node.js tutorials and job postings.">
            <div class="dark-container">
                <h2>What is Express.js?</h2>
                <p class="subtitle">Minimal, flexible Node.js web framework for building APIs.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Minimal</h4>
                        <p>Thin layer over Node.js HTTP. Fast and lightweight.</p>
                    </div>
                    <div class="dark-card">
                        <h4>Flexible</h4>
                        <p>Unopinionated - structure your app however you want.</p>
                    </div>
                    <div class="dark-card">
                        <h4>Popular</h4>
                        <p>Most used Node.js framework. Massive ecosystem.</p>
                    </div>
                </div>
                <div class="flow-diagram" style="margin-top: 1.5rem;">
                    <div class="endpoint-box client-box">
                        <div class="label">CLIENT</div>
                        <div class="title">Postman</div>
                    </div>
                    <div class="flow-arrow">
                        <span class="arrow">â†’</span>
                        <span class="label">Request</span>
                    </div>
                    <div class="endpoint-box server-box">
                        <div class="label">EXPRESS</div>
                        <div class="title">API Server</div>
                    </div>
                    <div class="flow-arrow">
                        <span class="arrow">â†’</span>
                        <span class="label">Read/Write</span>
                    </div>
                    <div class="endpoint-box db-box">
                        <div class="label">STORAGE</div>
                        <div class="title">tasks.json</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 15: Project Setup -->
        <section class="slide" id="express-setup" data-narration="Let's set up our Express project. First, create a new folder called express-tasks-api and navigate into it. Run npm init -y to create a package.json with default settings - the -y flag accepts all defaults so you don't have to answer questions. Then install Express with npm install express. You'll also want nodemon as a dev dependency - it automatically restarts your server when you save changes, which is invaluable during development. Create an index.js file - this will be our main entry point. Your folder should now have package.json, node_modules, and index.js. We're ready to write our first server!">
            <div class="dark-container">
                <h2><span class="step-number">1</span> Project Setup</h2>
                <p class="subtitle">Create a new Node.js project and install Express.</p>
                <div class="terminal-block">
                    <div><span class="prompt">$</span> <span class="command">mkdir express-tasks-api</span></div>
                    <div><span class="prompt">$</span> <span class="command">cd express-tasks-api</span></div>
                    <div><span class="prompt">$</span> <span class="command">npm init -y</span></div>
                    <div class="output" style="margin: 0.5rem 0;">Wrote to package.json</div>
                    <div><span class="prompt">$</span> <span class="command">npm install express</span></div>
                    <div><span class="prompt">$</span> <span class="command">npm install nodemon --save-dev</span></div>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>What's nodemon?</h4>
                    <p>Auto-restarts server when you save changes. Essential for development!</p>
                </div>
            </div>
        </section>

        <!-- Slide 16: Your First Server -->
        <section class="slide" id="first-server" data-narration="Here's the simplest possible Express server. We require express, then call it to create an app. The app.get line defines a route - when someone visits the root URL with a GET request, we send back 'Hello World'. Finally, app.listen starts the server on port 3000. Run this with node index.js and visit localhost:3000 in your browser. You should see 'Hello World'. That's your first API endpoint! The req parameter is the incoming request, res is the response you send back. Express gives you methods like res.send for text and res.json for JSON data, which we'll use next.">
            <div class="dark-container">
                <h2><span class="step-number">2</span> Your First Server</h2>
                <p class="subtitle">Create index.js with a basic Express server.</p>
                <div class="code-block">
<pre><span class="comment">// Note: Using CommonJS require() syntax for Express projects</span>
<span class="keyword">const</span> express = <span class="function">require</span>(<span class="string">'express'</span>);
<span class="keyword">const</span> app = <span class="function">express</span>();
<span class="keyword">const</span> PORT = <span class="number">3000</span>;

<span class="comment">// Define a route</span>
app.<span class="function">get</span>(<span class="string">'/'</span>, (req, res) => {
  res.<span class="function">send</span>(<span class="string">'Hello World!'</span>);
});

<span class="comment">// Start server</span>
app.<span class="function">listen</span>(PORT, () => {
  console.<span class="function">log</span>(<span class="string">`Server running on http://localhost:</span>${PORT}<span class="string">`</span>);
});</pre>
                </div>
                <div class="terminal-block" style="margin-top: 1rem;">
                    <div><span class="prompt">$</span> <span class="command">node index.js</span></div>
                    <div class="output">Server running on http://localhost:3000</div>
                </div>
            </div>
        </section>

        <!-- Slide 17: Understanding Routes -->
        <section class="slide" id="routes" data-narration="Routes define what happens when a request hits a specific URL with a specific method. Express provides methods matching each HTTP verb: app.get, app.post, app.put, app.delete. The first argument is the path - it can include parameters like :id that capture parts of the URL. The second argument is a callback function that receives req (the request) and res (the response). Inside the callback, you process the request and send a response. You can have multiple routes with the same path but different methods - GET /tasks returns all tasks, while POST /tasks creates a new one. This is REST in action.">
            <div class="dark-container">
                <h2><span class="step-number">3</span> Understanding Routes</h2>
                <p class="subtitle">Routes map HTTP methods and URLs to handler functions.</p>
                <div class="code-block">
<pre><span class="comment">// Route syntax: app.METHOD(path, handler)</span>

app.<span class="function">get</span>(<span class="string">'/tasks'</span>, (req, res) => {
  <span class="comment">// Handle GET /tasks</span>
});

app.<span class="function">post</span>(<span class="string">'/tasks'</span>, (req, res) => {
  <span class="comment">// Handle POST /tasks</span>
});

app.<span class="function">get</span>(<span class="string">'/tasks/:id'</span>, (req, res) => {
  <span class="comment">// Handle GET /tasks/123</span>
  <span class="comment">// req.params.id = "123"</span>
});

app.<span class="function">delete</span>(<span class="string">'/tasks/:id'</span>, (req, res) => {
  <span class="comment">// Handle DELETE /tasks/123</span>
});</pre>
                </div>
            </div>
        </section>

        <!-- Slide 18: Request Object -->
        <section class="slide" id="req-object" data-narration="The request object contains everything about the incoming request. There are three main ways to get data from requests. req.params contains URL parameters - for /tasks/123, req.params.id is '123'. Note it's always a string, so convert to number if needed. req.query contains query string parameters - for /tasks?completed=true, req.query.completed is 'true'. And req.body contains data sent in the request body, typically JSON from POST or PUT requests. To access req.body, you need to enable JSON parsing with middleware, which we'll do next. Understanding these three sources of data is essential for building APIs.">
            <div class="dark-container">
                <h2><span class="step-number">4</span> The Request Object</h2>
                <p class="subtitle">Three ways to receive data from clients.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>req.params</h4>
                        <p>URL parameters</p>
                        <div class="code-block" style="margin-top: 0.5rem; font-size: 0.8rem;">
<pre><span class="comment">// GET /tasks/123</span>
req.params.id
<span class="comment">// â†’ "123"</span></pre>
                        </div>
                    </div>
                    <div class="dark-card">
                        <h4>req.query</h4>
                        <p>Query string</p>
                        <div class="code-block" style="margin-top: 0.5rem; font-size: 0.8rem;">
<pre><span class="comment">// GET /tasks?done=true</span>
req.query.done
<span class="comment">// â†’ "true"</span></pre>
                        </div>
                    </div>
                    <div class="dark-card">
                        <h4>req.body</h4>
                        <p>JSON body data</p>
                        <div class="code-block" style="margin-top: 0.5rem; font-size: 0.8rem;">
<pre><span class="comment">// POST with JSON</span>
req.body.text
<span class="comment">// â†’ "Learn APIs"</span></pre>
                        </div>
                    </div>
                </div>
                <div class="dark-card warning" style="margin-top: 1rem;">
                    <h4>Important</h4>
                    <p><code>req.body</code> requires middleware to parse JSON. We'll add that next!</p>
                </div>
            </div>
        </section>

        <!-- Slide 19: Response Object -->
        <section class="slide" id="res-object" data-narration="The response object is how you send data back to the client. The most important method for APIs is res.json(), which sends a JSON response and automatically sets the Content-Type header. Use res.status() to set the HTTP status code - you can chain it with json like res.status(201).json(data). There's also res.send() for plain text and res.sendStatus() for status-only responses. Always send exactly one response per request - if you try to send multiple, you'll get an error. The pattern you'll use most often is checking conditions, then sending either success data or an error status with a message.">
            <div class="dark-container">
                <h2><span class="step-number">5</span> The Response Object</h2>
                <p class="subtitle">Methods for sending data back to clients.</p>
                <div class="code-block">
<pre><span class="comment">// Send JSON (most common for APIs)</span>
res.<span class="function">json</span>({ message: <span class="string">'Success'</span>, data: tasks });

<span class="comment">// Set status code + JSON</span>
res.<span class="function">status</span>(<span class="number">201</span>).<span class="function">json</span>(newTask);

<span class="comment">// Error response</span>
res.<span class="function">status</span>(<span class="number">404</span>).<span class="function">json</span>({ error: <span class="string">'Task not found'</span> });

<span class="comment">// Plain text (less common)</span>
res.<span class="function">send</span>(<span class="string">'Hello'</span>);

<span class="comment">// Status only, no body</span>
res.<span class="function">sendStatus</span>(<span class="number">204</span>); <span class="comment">// No Content</span></pre>
                </div>
                <div class="dark-card danger" style="margin-top: 1rem;">
                    <h4>One Response Per Request</h4>
                    <p>Only call <code>res.json()</code> or <code>res.send()</code> once. Multiple responses cause errors.</p>
                </div>
            </div>
        </section>

        <!-- Slide 20: Middleware -->
        <section class="slide" id="middleware" data-narration="Middleware are functions that run between receiving a request and sending a response. They can modify req and res, end the request cycle, or call next() to pass control to the next middleware. Express has built-in middleware like express.json() which parses JSON request bodies - without it, req.body would be undefined. Add middleware with app.use(). The order matters - add express.json() before your routes so the body is parsed by the time your route handler runs. You can also write custom middleware for logging, authentication, or error handling. Middleware is one of Express's most powerful features.">
            <div class="dark-container">
                <h2><span class="step-number">6</span> Middleware</h2>
                <p class="subtitle">Functions that process requests before they reach your routes.</p>
                <div class="code-block">
<pre><span class="keyword">const</span> express = <span class="function">require</span>(<span class="string">'express'</span>);
<span class="keyword">const</span> app = <span class="function">express</span>();

<span class="comment">// Built-in middleware: parse JSON bodies</span>
app.<span class="function">use</span>(express.<span class="function">json</span>());

<span class="comment">// Now req.body works in your routes!</span>
app.<span class="function">post</span>(<span class="string">'/tasks'</span>, (req, res) => {
  console.<span class="function">log</span>(req.body); <span class="comment">// { text: "Learn APIs" }</span>
  <span class="comment">// ...</span>
});</pre>
                </div>
                <div class="dark-card warning" style="margin-top: 1rem;">
                    <h4>Order Matters!</h4>
                    <p>Add <code>app.use(express.json())</code> BEFORE your routes, or <code>req.body</code> will be undefined.</p>
                </div>
            </div>
        </section>

        <!-- Slide 21: JSON File Storage -->
        <section class="slide" id="file-storage" data-narration="For our API, we'll store tasks in a JSON file. This is simpler than a database while still persisting data between server restarts. We use Node's built-in fs module with promises for cleaner async code. Create two helper functions: readTasks reads the file and parses JSON, writeTasks converts data to JSON and writes it. If the file doesn't exist, readTasks returns an empty array. Create an empty tasks.json file with just square brackets to start. These helper functions abstract away file operations so our route handlers stay clean. In production you'd use a real database, but this approach is perfect for learning.">
            <div class="dark-container">
                <h2><span class="step-number">7</span> JSON File Storage</h2>
                <p class="subtitle">Simple persistence using the file system.</p>
                <div class="code-block" style="font-size: 0.85rem;">
<pre><span class="keyword">const</span> fs = <span class="function">require</span>(<span class="string">'fs'</span>).promises;
<span class="keyword">const</span> DATA_FILE = <span class="string">'./tasks.json'</span>;

<span class="comment">// Helper: Read tasks from file</span>
<span class="keyword">async function</span> <span class="function">readTasks</span>() {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> data = <span class="keyword">await</span> fs.<span class="function">readFile</span>(DATA_FILE, <span class="string">'utf8'</span>);
    <span class="keyword">return</span> JSON.<span class="function">parse</span>(data);
  } <span class="keyword">catch</span> {
    <span class="keyword">return</span> []; <span class="comment">// Return empty array if file doesn't exist</span>
  }
}

<span class="comment">// Helper: Write tasks to file</span>
<span class="keyword">async function</span> <span class="function">writeTasks</span>(tasks) {
  <span class="keyword">await</span> fs.<span class="function">writeFile</span>(DATA_FILE, JSON.<span class="function">stringify</span>(tasks, <span class="keyword">null</span>, <span class="number">2</span>));
}</pre>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>Create tasks.json</h4>
                    <p>Start with an empty array: <code>[]</code></p>
                </div>
            </div>
        </section>

        <!-- Slide 22: GET /tasks -->
        <section class="slide" id="get-tasks" data-narration="Let's implement our first real endpoint: GET /tasks returns all tasks. The route handler is async because we're reading from the file system. We call our readTasks helper to get all tasks, then send them as JSON. If something goes wrong, we catch the error, log it for debugging, and send a 500 status with an error message. Test this in Postman: set the method to GET, the URL to http://localhost:3000/tasks, and click Send. You should get back an empty array at first. This is the 'Read all' operation in CRUD - the simplest and most common API endpoint.">
            <div class="dark-container">
                <h2><span class="step-number">8</span> GET /tasks - List All</h2>
                <p class="subtitle">Return all tasks from the JSON file.</p>
                <div class="code-block">
<pre>app.<span class="function">get</span>(<span class="string">'/tasks'</span>, <span class="keyword">async</span> (req, res) => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
    res.<span class="function">json</span>(tasks);
  } <span class="keyword">catch</span> (error) {
    console.<span class="function">error</span>(error);
    res.<span class="function">status</span>(<span class="number">500</span>).<span class="function">json</span>({ error: <span class="string">'Failed to read tasks'</span> });
  }
});</pre>
                </div>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div class="dark-card success">
                        <h4>Postman Test</h4>
                        <p><span class="method-pill get">GET</span> <code>http://localhost:3000/tasks</code></p>
                    </div>
                    <div class="dark-card">
                        <h4>Expected Response</h4>
                        <p><span class="status-badge success">200</span> <code>[]</code> (empty array initially)</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 23: GET /tasks/:id -->
        <section class="slide" id="get-task-by-id" data-narration="GET /tasks/:id returns a single task by its ID. The colon makes 'id' a URL parameter, accessible via req.params.id. Since URL parameters are always strings, we convert to a number with parseInt. We read all tasks, then use find() to locate the one with matching id. If no task is found, we return 404 Not Found - this is important for a proper REST API. If found, we return just that task. Test with a task ID that exists and one that doesn't to verify both paths work. This pattern of 'get one by ID' is fundamental to REST APIs.">
            <div class="dark-container">
                <h2><span class="step-number">9</span> GET /tasks/:id - Get One</h2>
                <p class="subtitle">Return a single task by its ID.</p>
                <div class="code-block">
<pre>app.<span class="function">get</span>(<span class="string">'/tasks/:id'</span>, <span class="keyword">async</span> (req, res) => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> id = <span class="function">parseInt</span>(req.params.id);
    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
    <span class="keyword">const</span> task = tasks.<span class="function">find</span>(t => t.id === id);

    <span class="keyword">if</span> (!task) {
      <span class="keyword">return</span> res.<span class="function">status</span>(<span class="number">404</span>).<span class="function">json</span>({ error: <span class="string">'Task not found'</span> });
    }

    res.<span class="function">json</span>(task);
  } <span class="keyword">catch</span> (error) {
    res.<span class="function">status</span>(<span class="number">500</span>).<span class="function">json</span>({ error: <span class="string">'Failed to read task'</span> });
  }
});</pre>
                </div>
                <div class="dark-card warning" style="margin-top: 1rem;">
                    <h4>Always Handle 404</h4>
                    <p>If the resource doesn't exist, return <span class="status-badge client-error">404</span> - don't return 200 with null!</p>
                </div>
            </div>
        </section>

        <!-- Slide 24: POST /tasks -->
        <section class="slide" id="post-task" data-narration="POST /tasks creates a new task. The client sends task data in the request body as JSON - we access it via req.body.text. First we validate that text was provided - if not, return 400 Bad Request. Then we create a new task object with a unique ID using Date.now(), the provided text, completed set to false, and a timestamp. We read existing tasks, add the new one, and write back to the file. Finally, we return 201 Created with the new task. The 201 status is important - it tells the client that something was created, not just that the request succeeded. Include the created resource in the response so the client knows the assigned ID.">
            <div class="dark-container">
                <h2><span class="step-number">10</span> POST /tasks - Create</h2>
                <p class="subtitle">Create a new task from request body data.</p>
                <div class="code-block" style="font-size: 0.85rem;">
<pre>app.<span class="function">post</span>(<span class="string">'/tasks'</span>, <span class="keyword">async</span> (req, res) => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> { text } = req.body;

    <span class="keyword">if</span> (!text) {
      <span class="keyword">return</span> res.<span class="function">status</span>(<span class="number">400</span>).<span class="function">json</span>({ error: <span class="string">'Text is required'</span> });
    }

    <span class="keyword">const</span> newTask = {
      id: Date.<span class="function">now</span>(),
      text,
      completed: <span class="keyword">false</span>,
      createdAt: <span class="keyword">new</span> <span class="function">Date</span>().<span class="function">toISOString</span>()
    };

    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
    tasks.<span class="function">push</span>(newTask);
    <span class="keyword">await</span> <span class="function">writeTasks</span>(tasks);

    res.<span class="function">status</span>(<span class="number">201</span>).<span class="function">json</span>(newTask);
  } <span class="keyword">catch</span> (error) {
    res.<span class="function">status</span>(<span class="number">500</span>).<span class="function">json</span>({ error: <span class="string">'Failed to create task'</span> });
  }
});</pre>
                </div>
            </div>
        </section>

        <!-- Slide 25: PUT /tasks/:id -->
        <section class="slide" id="put-task" data-narration="PUT /tasks/:id updates an existing task. We get the ID from the URL and the update data from the request body. Find the task's index in the array - if -1, it doesn't exist, return 404. Then we use the spread operator to merge the existing task with the new data, preserving the original id. This pattern lets clients send partial updates - just text, just completed, or both. We update the array at that index, write to file, and return the updated task. Some APIs use PATCH for partial updates and PUT for full replacement, but for simplicity we're using PUT for both. Test by creating a task first, then updating it.">
            <div class="dark-container">
                <h2><span class="step-number">11</span> PUT /tasks/:id - Update</h2>
                <p class="subtitle">Update an existing task with new data.</p>
                <div class="code-block" style="font-size: 0.85rem;">
<pre>app.<span class="function">put</span>(<span class="string">'/tasks/:id'</span>, <span class="keyword">async</span> (req, res) => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> id = <span class="function">parseInt</span>(req.params.id);
    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
    <span class="keyword">const</span> index = tasks.<span class="function">findIndex</span>(t => t.id === id);

    <span class="keyword">if</span> (index === -<span class="number">1</span>) {
      <span class="keyword">return</span> res.<span class="function">status</span>(<span class="number">404</span>).<span class="function">json</span>({ error: <span class="string">'Task not found'</span> });
    }

    <span class="comment">// Merge existing task with updates</span>
    tasks[index] = { ...tasks[index], ...req.body, id };
    <span class="keyword">await</span> <span class="function">writeTasks</span>(tasks);

    res.<span class="function">json</span>(tasks[index]);
  } <span class="keyword">catch</span> (error) {
    res.<span class="function">status</span>(<span class="number">500</span>).<span class="function">json</span>({ error: <span class="string">'Failed to update task'</span> });
  }
});</pre>
                </div>
            </div>
        </section>

        <!-- Slide 26: DELETE /tasks/:id -->
        <section class="slide" id="delete-task" data-narration="DELETE /tasks/:id removes a task. Get the ID from the URL, read all tasks, and use filter to create a new array without the task we're deleting. Filter keeps items where the condition is true - so we keep all tasks where the id doesn't match. If the filtered array has the same length as the original, nothing was removed, meaning the task didn't exist - return 404. Otherwise, write the filtered array to file and return 204 No Content, which indicates success with no response body. Some APIs return the deleted item, but 204 is the most RESTful choice for deletes.">
            <div class="dark-container">
                <h2><span class="step-number">12</span> DELETE /tasks/:id - Remove</h2>
                <p class="subtitle">Delete a task by ID.</p>
                <div class="code-block">
<pre>app.<span class="function">delete</span>(<span class="string">'/tasks/:id'</span>, <span class="keyword">async</span> (req, res) => {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> id = <span class="function">parseInt</span>(req.params.id);
    <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
    <span class="keyword">const</span> filtered = tasks.<span class="function">filter</span>(t => t.id !== id);

    <span class="keyword">if</span> (filtered.length === tasks.length) {
      <span class="keyword">return</span> res.<span class="function">status</span>(<span class="number">404</span>).<span class="function">json</span>({ error: <span class="string">'Task not found'</span> });
    }

    <span class="keyword">await</span> <span class="function">writeTasks</span>(filtered);
    res.<span class="function">sendStatus</span>(<span class="number">204</span>); <span class="comment">// No Content</span>
  } <span class="keyword">catch</span> (error) {
    res.<span class="function">status</span>(<span class="number">500</span>).<span class="function">json</span>({ error: <span class="string">'Failed to delete task'</span> });
  }
});</pre>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>204 No Content</h4>
                    <p>Success with no response body. Perfect for DELETE operations.</p>
                </div>
            </div>
        </section>

        <!-- Slide 27: CORS Explained -->
        <section class="slide" id="cors" data-narration="CORS, Cross-Origin Resource Sharing, is a security feature you'll encounter when your frontend and backend run on different domains or ports. By default, browsers block requests from one origin to another - this prevents malicious sites from accessing APIs. When your React app on localhost:5173 tries to call your Express API on localhost:3000, the browser blocks it unless the server explicitly allows it. To enable CORS in Express, install the cors package and use it as middleware. In development, cors() with no arguments allows all origins. In production, you'd configure it to allow only your frontend's domain. You'll hit this immediately if you try to connect your React app to your API.">
            <div class="dark-container">
                <h2><span class="step-number">13</span> CORS Explained</h2>
                <p class="subtitle">Cross-Origin Resource Sharing - enabling frontend-backend communication.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3 style="color: #f87171;">The Problem</h3>
                        <p style="margin: 0.5rem 0;">Browsers block requests between different origins (domains/ports) for security.</p>
                        <div class="dark-card danger" style="margin-top: 0.5rem;">
                            <p><code>localhost:5173</code> (React) â†’ <code>localhost:3000</code> (Express) = <strong>Blocked!</strong></p>
                        </div>
                    </div>
                    <div>
                        <h3 style="color: #4ade80;">The Solution</h3>
                        <div class="terminal-block" style="margin-top: 0.5rem;">
                            <div><span class="prompt">$</span> <span class="command">npm install cors</span></div>
                        </div>
                        <div class="code-block" style="margin-top: 0.5rem; font-size: 0.8rem;">
<pre><span class="keyword">const</span> cors = <span class="function">require</span>(<span class="string">'cors'</span>);
app.<span class="function">use</span>(<span class="function">cors</span>()); <span class="comment">// Allow all</span></pre>
                        </div>
                    </div>
                </div>
                <div class="dark-card warning" style="margin-top: 1rem;">
                    <h4>For Production</h4>
                    <p>Configure specific origins: <code>cors({ origin: 'https://yourapp.com' })</code></p>
                </div>
            </div>
        </section>

        <!-- Slide 28: Testing with Postman -->
        <section class="slide" id="postman-testing" data-narration="Now let's test all our endpoints in Postman. Create a new collection called 'Tasks API'. Add a request for each endpoint: GET all tasks, GET single task, POST to create, PUT to update, DELETE to remove. For POST and PUT, go to the Body tab, select raw, choose JSON from the dropdown, and enter your JSON data. Test the complete flow: create a task, get all tasks to see it, get it by ID, update it, then delete it. Save each request to your collection. When you're done, export the collection - you'll submit this JSON file with your assignment. The collection serves as documentation and proof of testing.">
            <div class="dark-container">
                <h2><span class="step-number">14</span> Testing with Postman</h2>
                <p class="subtitle">Test all endpoints and save to a collection.</p>
                <table class="dark-table">
                    <tr>
                        <th>Method</th>
                        <th>URL</th>
                        <th>Body</th>
                        <th>Expected</th>
                    </tr>
                    <tr>
                        <td><span class="method-pill get">GET</span></td>
                        <td><code>/tasks</code></td>
                        <td>-</td>
                        <td><span class="status-badge success">200</span> Array</td>
                    </tr>
                    <tr>
                        <td><span class="method-pill get">GET</span></td>
                        <td><code>/tasks/123</code></td>
                        <td>-</td>
                        <td><span class="status-badge success">200</span> Object</td>
                    </tr>
                    <tr>
                        <td><span class="method-pill post">POST</span></td>
                        <td><code>/tasks</code></td>
                        <td><code>{"text": "..."}</code></td>
                        <td><span class="status-badge created">201</span> Created</td>
                    </tr>
                    <tr>
                        <td><span class="method-pill put">PUT</span></td>
                        <td><code>/tasks/123</code></td>
                        <td><code>{"completed": true}</code></td>
                        <td><span class="status-badge success">200</span> Updated</td>
                    </tr>
                    <tr>
                        <td><span class="method-pill delete">DELETE</span></td>
                        <td><code>/tasks/123</code></td>
                        <td>-</td>
                        <td><span class="status-badge success">204</span> No Content</td>
                    </tr>
                </table>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>Export Collection</h4>
                    <p>Right-click collection â†’ Export â†’ Collection v2.1. Submit this JSON file!</p>
                </div>
            </div>
        </section>

        <!-- Slide 29: Assignment 1 Link -->
        <section class="slide" id="assignment1" data-narration="Assignment 1 is to build the Tasks API in Express.js. Click the link to open the full step-by-step assignment instructions. The assignment walks you through creating the project, implementing all five CRUD endpoints, testing with Postman, and submitting your work. This assignment is worth 50 points.">
            <div class="dark-container" style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%;">
                <h2>Assignment 1: Express.js Tasks API</h2>
                <p class="subtitle" style="margin-bottom: 2rem;">Build and test a complete CRUD API with Express.</p>
                <div style="margin: 2rem 0;">
                    <a href="../assignments/assignment-1-express-tasks-api.html"
                       style="display: inline-block; padding: 1rem 2rem; background: linear-gradient(135deg, #667eea, #764ba2); color: #fff; text-decoration: none; border-radius: 8px; font-size: 1.25rem; font-weight: bold; transition: transform 0.2s, box-shadow 0.2s;"
                       onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(102,126,234,0.4)';"
                       onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                        Open Assignment Instructions
                    </a>
                </div>
                <div class="dark-three-column" style="margin-top: 2rem; max-width: 700px; margin-left: auto; margin-right: auto;">
                    <div class="dark-card">
                        <h4>1. GitHub Repo</h4>
                        <p>Complete source code</p>
                    </div>
                    <div class="dark-card">
                        <h4>2. Postman</h4>
                        <p>Exported .json file</p>
                    </div>
                    <div class="dark-card">
                        <h4>3. Screenshots</h4>
                        <p>Successful tests</p>
                    </div>
                </div>
                <div style="margin-top: 2rem;">
                    <p style="color: #fbbf24; font-size: 1.5rem; font-weight: bold;">50 Points</p>
                </div>
            </div>
        </section>

        <!-- Assignment 1 step-by-step instructions moved to: assignments/assignment-1-express-tasks-api.html -->
        <!-- ========== PART 3: Next.js API Routes ========== -->

        <!-- Slide 30: Part 3 Title -->
        <section class="slide title-slide" id="part3" data-narration="Part 3 introduces a different approach to building APIs: Next.js Route Handlers. Instead of a separate backend server, Next.js lets you add API routes directly to your React project. This means one codebase, one deployment, one URL for both frontend and backend. We'll rebuild the exact same Tasks API so you can directly compare how each framework handles the same problem. You already know Next.js deploys easily to Vercel from Module 5 - now you'll add API routes to that same deployment model. Let's see how Next.js does APIs differently.">
            <h1>Part 3</h1>
            <p class="subtitle">API Routes with Next.js</p>
        </section>

        <!-- Slide 31: What is Next.js? -->
        <section class="slide" id="what-is-nextjs" data-narration="Next.js is a React framework that adds server-side capabilities to React. While React alone is a client-side library, Next.js lets you build full-stack applications with server rendering, file-based routing, and API routes. Created by Vercel, it's designed to work seamlessly with their hosting platform. The big advantage for APIs is that you can put your frontend and backend in the same project. Your React components and API routes live in the same codebase, share the same deployment, and run under the same URL. This simplifies development and deployment significantly, especially for smaller projects.">
            <div class="dark-container">
                <h2>What is Next.js?</h2>
                <p class="subtitle">A React framework with full-stack capabilities.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Full-Stack React</h4>
                        <p>Frontend + backend in one project. Server-side rendering built in.</p>
                    </div>
                    <div class="dark-card">
                        <h4>File-Based Routing</h4>
                        <p>Files and folders become URLs. No router configuration needed.</p>
                    </div>
                    <div class="dark-card">
                        <h4>Easy Deployment</h4>
                        <p>Deploys to Vercel in seconds. You already did this in Module 5!</p>
                    </div>
                </div>
                <div class="flow-diagram" style="margin-top: 1.5rem;">
                    <div class="endpoint-box" style="border-color: #22d3ee;">
                        <div class="label" style="color: #22d3ee;">PAGES</div>
                        <div class="title">React UI</div>
                    </div>
                    <div style="font-size: 2rem; color: #94a3b8;">+</div>
                    <div class="endpoint-box" style="border-color: #f97316;">
                        <div class="label" style="color: #f97316;">API ROUTES</div>
                        <div class="title">Backend</div>
                    </div>
                    <div style="font-size: 2rem; color: #94a3b8;">=</div>
                    <div class="endpoint-box" style="border-color: #4ade80;">
                        <div class="label" style="color: #4ade80;">ONE PROJECT</div>
                        <div class="title">Full Stack</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 32: App Router Overview -->
        <section class="slide" id="app-router" data-narration="Next.js 13 introduced the App Router, a new way to structure Next.js applications. All your code lives in the 'app' folder. Folders become URL paths, and special files define what happens at those paths: page.js for UI, route.js for API endpoints. For API routes, you create folders under app/api. The folder path becomes the URL: app/api/tasks/route.js handles requests to /api/tasks. Dynamic segments use square brackets: app/api/tasks/[id]/route.js handles /api/tasks/123. This file-based approach means you can see your entire API structure just by looking at the folder tree.">
            <div class="dark-container">
                <h2>App Router Overview</h2>
                <p class="subtitle">File-based routing - folders and files become URLs.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3>Folder Structure</h3>
                        <div class="code-block" style="margin-top: 0.5rem; font-size: 0.85rem;">
<pre>app/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ tasks/
â”‚       â”œâ”€â”€ route.js      <span class="comment">â† /api/tasks</span>
â”‚       â””â”€â”€ [id]/
â”‚           â””â”€â”€ route.js  <span class="comment">â† /api/tasks/:id</span>
â”œâ”€â”€ page.js               <span class="comment">â† / (homepage)</span>
â””â”€â”€ layout.js</pre>
                        </div>
                    </div>
                    <div>
                        <h3>Key Concepts</h3>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>route.js</h4>
                            <p>Defines API endpoint handlers</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>[id] folder</h4>
                            <p>Dynamic segment - captures URL params</p>
                        </div>
                        <div class="dark-card" style="margin-top: 0.5rem;">
                            <h4>/api prefix</h4>
                            <p>Convention to separate from pages</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 33: Route Handlers -->
        <section class="slide" id="route-handlers" data-narration="Route handlers are how you define API endpoints in Next.js. Instead of app.get and app.post like Express, you export functions named after HTTP methods in uppercase: GET, POST, PUT, DELETE. Each function receives a Request object and returns a Response using NextResponse. This is closer to the web platform's native Request and Response APIs, making Next.js more standards-aligned than Express. The function names must be exactly GET, POST, PUT, or DELETE - Next.js uses these names to know which function handles which HTTP method. You can have multiple handlers in the same route.js file.">
            <div class="dark-container">
                <h2>Route Handlers</h2>
                <p class="subtitle">Export functions named after HTTP methods.</p>
                <div class="code-block">
<pre><span class="comment">// app/api/tasks/route.js</span>
<span class="keyword">import</span> { NextResponse } <span class="keyword">from</span> <span class="string">'next/server'</span>;

<span class="keyword">export async function</span> <span class="function">GET</span>(request) {
  <span class="comment">// Handle GET /api/tasks</span>
  <span class="keyword">return</span> NextResponse.<span class="function">json</span>({ message: <span class="string">'Hello'</span> });
}

<span class="keyword">export async function</span> <span class="function">POST</span>(request) {
  <span class="comment">// Handle POST /api/tasks</span>
  <span class="keyword">const</span> body = <span class="keyword">await</span> request.<span class="function">json</span>();
  <span class="keyword">return</span> NextResponse.<span class="function">json</span>(body, { status: <span class="number">201</span> });
}</pre>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>Key Difference from Express</h4>
                    <p>Function name = HTTP method. <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> (uppercase!)</p>
                </div>
            </div>
        </section>

        <!-- Slide 34: Project Setup -->
        <section class="slide" id="nextjs-setup" data-narration="Let's set up our Next.js project. Run npx create-next-app@latest and name it nextjs-tasks-api. When prompted, accept the defaults - we want TypeScript disabled for simplicity, ESLint enabled, Tailwind optional, the src directory is up to you, and importantly, say yes to App Router. After creation, cd into the project and run npm run dev. The development server starts on localhost:3000. Now create the api folder structure: app/api/tasks/route.js for the collection endpoints and app/api/tasks/[id]/route.js for single-item endpoints. The square brackets are literal - they tell Next.js this is a dynamic segment.">
            <div class="dark-container">
                <h2><span class="step-number">1</span> Project Setup</h2>
                <p class="subtitle">Create a Next.js project with App Router.</p>
                <div class="terminal-block">
                    <div><span class="prompt">$</span> <span class="command">npx create-next-app@latest nextjs-tasks-api</span></div>
                    <div class="output" style="margin: 0.5rem 0;">âœ” Would you like to use TypeScript? No</div>
                    <div class="output">âœ” Would you like to use App Router? Yes</div>
                    <div style="margin-top: 1rem;"><span class="prompt">$</span> <span class="command">cd nextjs-tasks-api</span></div>
                    <div><span class="prompt">$</span> <span class="command">npm run dev</span></div>
                    <div class="output" style="margin-top: 0.5rem;">â–² Ready on http://localhost:3000</div>
                </div>
                <div class="dark-card info" style="margin-top: 1rem;">
                    <h4>Create API Folders</h4>
                    <p><code>app/api/tasks/route.js</code> and <code>app/api/tasks/[id]/route.js</code></p>
                </div>
            </div>
        </section>

        <!-- Slide 35: NextRequest & NextResponse -->
        <section class="slide" id="next-request-response" data-narration="Next.js uses NextRequest and NextResponse from next/server. These are extensions of the standard web Request and Response APIs. To read JSON from the request body, use await request.json(). To get URL parameters in dynamic routes, the second argument to your handler contains params - await it and destructure: const { id } = await params. To send responses, use NextResponse.json() with your data and optional status. You can also create responses with other status codes or headers. The API is more explicit than Express - you return responses instead of calling res.json(). This functional style makes handlers easier to test.">
            <div class="dark-container">
                <h2><span class="step-number">2</span> NextRequest & NextResponse</h2>
                <p class="subtitle">Web-standard APIs for handling requests and responses.</p>
                <div class="code-block">
<pre><span class="keyword">import</span> { NextResponse } <span class="keyword">from</span> <span class="string">'next/server'</span>;

<span class="comment">// Reading request body</span>
<span class="keyword">const</span> body = <span class="keyword">await</span> request.<span class="function">json</span>();

<span class="comment">// Getting URL params (in [id]/route.js)</span>
<span class="keyword">export async function</span> <span class="function">GET</span>(request, { params }) {
  <span class="keyword">const</span> { id } = <span class="keyword">await</span> params;
}

<span class="comment">// Sending responses</span>
<span class="keyword">return</span> NextResponse.<span class="function">json</span>(data);
<span class="keyword">return</span> NextResponse.<span class="function">json</span>(data, { status: <span class="number">201</span> });
<span class="keyword">return</span> NextResponse.<span class="function">json</span>({ error: <span class="string">'Not found'</span> }, { status: <span class="number">404</span> });</pre>
                </div>
            </div>
        </section>

        <!-- Slide 36: GET & POST Routes -->
        <section class="slide" id="next-get-post" data-narration="Let's implement GET and POST for the tasks collection. Create app/api/tasks/route.js. Both handlers use the same file storage helpers we created for Express - copy those over or recreate them. The GET handler reads all tasks and returns them as JSON. The POST handler reads the JSON body, validates that text exists, creates the new task object, saves it, and returns 201 with the created task. Notice we export named functions GET and POST - Next.js routes requests to the right handler based on the HTTP method. The pattern is very similar to Express, just with different syntax.">
            <div class="dark-container">
                <h2><span class="step-number">3</span> GET & POST Routes</h2>
                <p class="subtitle">app/api/tasks/route.js - handle collection endpoints.</p>
                <div class="code-block" style="font-size: 0.8rem;">
<pre><span class="keyword">import</span> { NextResponse } <span class="keyword">from</span> <span class="string">'next/server'</span>;
<span class="keyword">import</span> { readTasks, writeTasks } <span class="keyword">from</span> <span class="string">'@/lib/tasks'</span>;

<span class="keyword">export async function</span> <span class="function">GET</span>() {
  <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
  <span class="keyword">return</span> NextResponse.<span class="function">json</span>(tasks);
}

<span class="keyword">export async function</span> <span class="function">POST</span>(request) {
  <span class="keyword">const</span> { text } = <span class="keyword">await</span> request.<span class="function">json</span>();
  <span class="keyword">if</span> (!text) {
    <span class="keyword">return</span> NextResponse.<span class="function">json</span>({ error: <span class="string">'Text required'</span> }, { status: <span class="number">400</span> });
  }
  <span class="keyword">const</span> newTask = { id: Date.<span class="function">now</span>(), text, completed: <span class="keyword">false</span> };
  <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
  tasks.<span class="function">push</span>(newTask);
  <span class="keyword">await</span> <span class="function">writeTasks</span>(tasks);
  <span class="keyword">return</span> NextResponse.<span class="function">json</span>(newTask, { status: <span class="number">201</span> });
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 37: Dynamic Routes -->
        <section class="slide" id="next-dynamic" data-narration="For single-task operations, create app/api/tasks/[id]/route.js. The square brackets make this a dynamic segment - any request to /api/tasks/123 routes here with 123 as the id param. Each handler receives the params object as the second argument. We implement GET to fetch one task, PUT to update it, and DELETE to remove it. The logic is identical to Express - find by id, handle 404 if not found, perform the operation, return the result. The difference is purely syntactic: named function exports instead of app.method calls, NextResponse.json instead of res.json.">
            <div class="dark-container">
                <h2><span class="step-number">4</span> Dynamic Routes</h2>
                <p class="subtitle">app/api/tasks/[id]/route.js - handle single task operations.</p>
                <div class="code-block" style="font-size: 0.8rem;">
<pre><span class="keyword">export async function</span> <span class="function">GET</span>(request, { params }) {
  <span class="keyword">const</span> { id } = <span class="keyword">await</span> params;
  <span class="keyword">const</span> parsedId = <span class="function">parseInt</span>(id);
  <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
  <span class="keyword">const</span> task = tasks.<span class="function">find</span>(t => t.id === parsedId);
  <span class="keyword">if</span> (!task) {
    <span class="keyword">return</span> NextResponse.<span class="function">json</span>({ error: <span class="string">'Not found'</span> }, { status: <span class="number">404</span> });
  }
  <span class="keyword">return</span> NextResponse.<span class="function">json</span>(task);
}

<span class="keyword">export async function</span> <span class="function">DELETE</span>(request, { params }) {
  <span class="keyword">const</span> { id } = <span class="keyword">await</span> params;
  <span class="keyword">const</span> parsedId = <span class="function">parseInt</span>(id);
  <span class="keyword">const</span> tasks = <span class="keyword">await</span> <span class="function">readTasks</span>();
  <span class="keyword">const</span> filtered = tasks.<span class="function">filter</span>(t => t.id !== parsedId);
  <span class="keyword">if</span> (filtered.length === tasks.length) {
    <span class="keyword">return</span> NextResponse.<span class="function">json</span>({ error: <span class="string">'Not found'</span> }, { status: <span class="number">404</span> });
  }
  <span class="keyword">await</span> <span class="function">writeTasks</span>(filtered);
  <span class="keyword">return new</span> <span class="function">Response</span>(<span class="keyword">null</span>, { status: <span class="number">204</span> });
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 38: File Storage in Next.js -->
        <section class="slide" id="next-storage" data-narration="For file storage in Next.js, create a lib folder for shared utilities. The readTasks and writeTasks functions are almost identical to Express, with one important difference: we need the full file path. In Next.js, use process.cwd() to get the project root directory, then join it with your data file path. Create tasks.json in your project root with an empty array. One note for deployment: Vercel's serverless functions have read-only file systems, so JSON file storage won't persist across requests in production. For this assignment that's fine - we're focusing on learning the API patterns. In a real app, you'd use a database.">
            <div class="dark-container">
                <h2><span class="step-number">5</span> File Storage in Next.js</h2>
                <p class="subtitle">Create lib/tasks.js with helper functions.</p>
                <div class="code-block" style="font-size: 0.85rem;">
<pre><span class="comment">// lib/tasks.js</span>
<span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs/promises'</span>;
<span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;

<span class="keyword">const</span> DATA_FILE = path.<span class="function">join</span>(process.<span class="function">cwd</span>(), <span class="string">'tasks.json'</span>);

<span class="keyword">export async function</span> <span class="function">readTasks</span>() {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> data = <span class="keyword">await</span> fs.<span class="function">readFile</span>(DATA_FILE, <span class="string">'utf8'</span>);
    <span class="keyword">return</span> JSON.<span class="function">parse</span>(data);
  } <span class="keyword">catch</span> {
    <span class="keyword">return</span> [];
  }
}

<span class="keyword">export async function</span> <span class="function">writeTasks</span>(tasks) {
  <span class="keyword">await</span> fs.<span class="function">writeFile</span>(DATA_FILE, JSON.<span class="function">stringify</span>(tasks, <span class="keyword">null</span>, <span class="number">2</span>));
}</pre>
                </div>
                <div class="dark-card warning" style="margin-top: 1rem;">
                    <h4>Vercel Note</h4>
                    <p>File storage is read-only on Vercel. For production, use a database.</p>
                </div>
            </div>
        </section>

        <!-- Slide 39: Express vs Next.js -->
        <section class="slide" id="comparison" data-narration="Let's compare Express and Next.js side by side. In Express, you call app.get, app.post, etc. and define routes in one file. In Next.js, you export named functions GET, POST, etc. from route.js files. Express uses req and res objects with methods like res.json(). Next.js uses NextRequest and NextResponse with return statements. Express runs as a standalone server; Next.js API routes are serverless functions. When should you choose each? Use Express when you need a dedicated backend, complex middleware, or WebSockets. Use Next.js when you want frontend and backend together, easy deployment, or serverless architecture. Both are valid choices - now you know both approaches!">
            <div class="dark-container">
                <h2>Express vs Next.js Comparison</h2>
                <p class="subtitle">Same API, different approaches.</p>
                <table class="dark-table" style="font-size: 0.9rem;">
                    <tr>
                        <th>Aspect</th>
                        <th>Express.js</th>
                        <th>Next.js</th>
                    </tr>
                    <tr>
                        <td><strong style="color: #fff;">Routing</strong></td>
                        <td><code>app.get('/tasks', ...)</code></td>
                        <td><code>export function GET()</code></td>
                    </tr>
                    <tr>
                        <td><strong style="color: #fff;">Response</strong></td>
                        <td><code>res.json(data)</code></td>
                        <td><code>return NextResponse.json(data)</code></td>
                    </tr>
                    <tr>
                        <td><strong style="color: #fff;">Params</strong></td>
                        <td><code>req.params.id</code></td>
                        <td><code>{ params } â†’ await params</code></td>
                    </tr>
                    <tr>
                        <td><strong style="color: #fff;">Body</strong></td>
                        <td><code>req.body</code></td>
                        <td><code>await request.json()</code></td>
                    </tr>
                    <tr>
                        <td><strong style="color: #fff;">Deployment</strong></td>
                        <td>Standalone server</td>
                        <td>Serverless (Vercel)</td>
                    </tr>
                </table>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div class="dark-card">
                        <h4>Choose Express When</h4>
                        <p>Dedicated backend, complex middleware, WebSockets</p>
                    </div>
                    <div class="dark-card">
                        <h4>Choose Next.js When</h4>
                        <p>Full-stack app, easy deploy, serverless fits</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 40: Assignment 2 Link -->
        <section class="slide" id="assignment2" data-narration="Assignment 2 is to build the same Tasks API in Next.js. Click the link to open the full step-by-step assignment instructions. The assignment walks you through creating the project, implementing route handlers, deploying to Vercel, and testing your live API. This assignment is worth 50 points.">
            <div class="dark-container" style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%;">
                <h2>Assignment 2: Next.js Tasks API</h2>
                <p class="subtitle" style="margin-bottom: 2rem;">Rebuild the same API using Next.js Route Handlers.</p>
                <div style="margin: 2rem 0;">
                    <a href="../assignments/assignment-2-nextjs-tasks-api.html"
                       style="display: inline-block; padding: 1rem 2rem; background: linear-gradient(135deg, #667eea, #764ba2); color: #fff; text-decoration: none; border-radius: 8px; font-size: 1.25rem; font-weight: bold; transition: transform 0.2s, box-shadow 0.2s;"
                       onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(102,126,234,0.4)';"
                       onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                        Open Assignment Instructions
                    </a>
                </div>
                <div class="dark-three-column" style="margin-top: 2rem; max-width: 700px; margin-left: auto; margin-right: auto;">
                    <div class="dark-card">
                        <h4>1. GitHub Repo</h4>
                        <p>Complete source code</p>
                    </div>
                    <div class="dark-card">
                        <h4>2. Vercel URL</h4>
                        <p>Live deployed API</p>
                    </div>
                    <div class="dark-card">
                        <h4>3. Screenshots</h4>
                        <p>Live API tests</p>
                    </div>
                </div>
                <div style="margin-top: 2rem;">
                    <p style="color: #fbbf24; font-size: 1.5rem; font-weight: bold;">50 Points</p>
                </div>
            </div>
        </section>

        <!-- Module Complete -->
        <section class="slide" id="module-complete" data-narration="Congratulations on completing Module 6! You've learned what APIs are and how REST architecture works. You understand HTTP methods, status codes, and URL design. You built a complete CRUD API in Express.js and rebuilt it in Next.js, seeing how two major frameworks approach the same problem. You tested APIs with Postman and learned about CORS. These backend skills complement the React frontend skills from Module 5. You can now build full-stack applications - frontend, backend, and deployment. Keep practicing by adding features: authentication, filtering, pagination. The fundamentals you learned here apply to any backend framework. Great work!">
            <div class="dark-container">
                <h2>Module 6 Complete!</h2>
                <p class="subtitle">You can now build RESTful APIs with Express.js and Next.js.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>What You Learned</h4>
                        <ul style="margin: 0; padding-left: 1.5rem;">
                            <li>REST architecture principles</li>
                            <li>HTTP methods and status codes</li>
                            <li>Express.js API development</li>
                            <li>Next.js Route Handlers</li>
                            <li>API testing with Postman</li>
                            <li>CORS and cross-origin requests</li>
                        </ul>
                    </div>
                    <div class="dark-card">
                        <h4>Keep Practicing!</h4>
                        <p>Try adding these features:</p>
                        <ul style="margin: 0.5rem 0 0; padding-left: 1.5rem;">
                            <li>Filter tasks by completed status</li>
                            <li>Sort by date or alphabetically</li>
                            <li>Pagination for large lists</li>
                            <li>Connect your React Todo app!</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <script src="../js/slides.js"></script>
</body>
</html>
