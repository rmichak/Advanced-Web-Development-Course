<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Module 3 - JavaScript Fundamentals">
    <title>Module 3: JavaScript Fundamentals | Advanced Web Development</title>
    <link rel="stylesheet" href="../css/slides.css">
    <style>
        /* Dark theme components */
        .dark-container {
            background: linear-gradient(135deg, #1a2332 0%, #2d3748 100%);
            border-radius: 12px;
            padding: 2rem;
            border-left: 4px solid;
            border-image: linear-gradient(180deg, #06b6d4, #f97316, #ef4444) 1;
        }
        .dark-container h2 { color: #fff; margin: 0 0 0.5rem 0; font-size: 1.8rem; }
        .dark-container .subtitle { color: #94a3b8; margin-bottom: 1.5rem; }
        .dark-container h3 { color: #2dd4bf; margin-top: 1rem; }
        .dark-container ul { color: #94a3b8; }
        .dark-container li { margin-bottom: 0.5rem; }
        .dark-container strong { color: #fff; }
        .dark-container p { color: #94a3b8; }
        .dark-container code { background: #2d3a4d; color: #2dd4bf; padding: 0.2rem 0.4rem; border-radius: 4px; }

        .dark-two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
        .dark-three-column { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; }
        .dark-four-column { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; }

        .dark-card {
            background: #2d3a4d;
            border-radius: 8px;
            padding: 1rem;
            border-left: 3px solid #2dd4bf;
        }
        .dark-card h4 { color: #fff; margin: 0 0 0.5rem 0; }
        .dark-card p { color: #94a3b8; font-size: 0.9rem; margin: 0; }
        .dark-card.warning { border-left-color: #facc15; }
        .dark-card.danger { border-left-color: #f87171; }
        .dark-card.info { border-left-color: #22d3ee; }

        .dark-table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        .dark-table th { background: #3d4a5d; color: #fff; padding: 0.75rem 1rem; text-align: left; }
        .dark-table td { background: #2d3a4d; color: #94a3b8; padding: 0.75rem 1rem; border-bottom: 1px solid #3d4a5d; }
        .dark-table code { background: #1a2332; color: #2dd4bf; padding: 0.2rem 0.4rem; border-radius: 4px; }

        .timeline { position: relative; padding-left: 2rem; }
        .timeline-item { position: relative; margin-bottom: 1.5rem; padding-left: 1.5rem; border-left: 2px solid #3d4a5d; }
        .timeline-item::before { content: ''; position: absolute; left: -0.5rem; top: 0.25rem; width: 1rem; height: 1rem; background: #2dd4bf; border-radius: 50%; }
        .timeline-year { color: #2dd4bf; font-weight: bold; font-size: 1.1rem; }
        .timeline-content { color: #94a3b8; margin-top: 0.25rem; }

        .big-number { font-size: 4rem; font-weight: bold; color: #2dd4bf; line-height: 1; }
        .stat-label { color: #94a3b8; font-size: 1.1rem; margin-top: 0.5rem; }

        .code-block { background: #1a2332; border-radius: 8px; padding: 1rem; overflow-x: auto; }
        .code-block pre { margin: 0; color: #e2e8f0; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.9rem; }
        .code-block .comment { color: #6b7280; }
        .code-block .keyword { color: #c084fc; }
        .code-block .string { color: #4ade80; }
        .code-block .function { color: #60a5fa; }
        .code-block .number { color: #f472b6; }

        .flow-diagram { display: flex; align-items: center; justify-content: center; gap: 1rem; margin: 2rem 0; flex-wrap: wrap; }
        .flow-box { background: #2d3a4d; border-radius: 8px; padding: 1rem 1.5rem; text-align: center; border: 2px solid #3d4a5d; }
        .flow-box.highlight { border-color: #2dd4bf; }
        .flow-box .label { color: #94a3b8; font-size: 0.8rem; text-transform: uppercase; }
        .flow-box .value { color: #fff; font-size: 1.1rem; font-weight: 600; margin-top: 0.25rem; }
        .flow-arrow { color: #94a3b8; font-size: 1.5rem; }

        .feature-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .feature-item { display: flex; align-items: flex-start; gap: 0.75rem; }
        .feature-icon { color: #2dd4bf; font-size: 1.25rem; }
        .feature-text { color: #94a3b8; }
        .feature-text strong { color: #fff; display: block; margin-bottom: 0.25rem; }

        @media (max-width: 900px) {
            .dark-two-column, .dark-three-column { grid-template-columns: 1fr; }
            .dark-four-column { grid-template-columns: repeat(2, 1fr); }
            .feature-grid { grid-template-columns: 1fr; }
        }

        /* Video thumbnail styles */
        .video-thumbnail {
            display: block;
            max-width: 560px;
            margin: 1.5rem auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            text-decoration: none;
        }
        .video-thumbnail:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }
        .video-thumbnail img {
            width: 100%;
            display: block;
        }
        .video-thumbnail .video-info {
            background: #0a66c2;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .video-thumbnail .video-info .linkedin-logo {
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #0a66c2;
            font-size: 14px;
        }
        .video-thumbnail .video-info .video-title {
            color: #fff;
            font-weight: 600;
            font-size: 1.1rem;
        }
        .video-thumbnail .video-info .video-meta {
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
            margin-left: auto;
        }

        /* Resource links styles */
        .resource-list {
            list-style: none;
            padding: 0;
            margin: 1.5rem 0;
        }
        .resource-list li {
            margin-bottom: 1rem;
        }
        .resource-link {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: #2d3a4d;
            border-radius: 8px;
            text-decoration: none;
            transition: background 0.2s ease, transform 0.2s ease;
            border-left: 3px solid #2dd4bf;
        }
        .resource-link:hover {
            background: #3d4a5d;
            transform: translateX(4px);
        }
        .resource-link .resource-icon {
            font-size: 1.5rem;
            width: 40px;
            text-align: center;
        }
        .resource-link .resource-info h4 {
            color: #fff;
            margin: 0 0 0.25rem 0;
            font-size: 1.1rem;
        }
        .resource-link .resource-info p {
            color: #94a3b8;
            margin: 0;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- ========== PART 1: JavaScript History & Origins ========== -->

        <!-- Slide 1: Title -->
        <section class="slide title-slide" data-narration="Welcome to Module 3 where we'll explore JavaScript fundamentals. This comprehensive module covers everything from JavaScript's origins to modern development practices. JavaScript is the programming language of the web, running in every browser and now on servers via Node.js. We'll trace its 10-day creation story, understand ECMAScript standardization, and learn the core language features you'll use every day. By the end, you'll understand both the 'why' behind JavaScript's quirks and the 'how' of writing modern, clean code. This knowledge forms the foundation for everything else in web development.">
            <h1>Module 3</h1>
            <p class="subtitle">JavaScript Fundamentals</p>
            <p class="meta">Advanced Web Development</p>
        </section>

        <!-- Recommended Resource: LinkedIn Learning -->
        <section class="slide" id="linkedin-learning" data-narration="Before we dive in, I recommend this LinkedIn Learning course on JavaScript Essential Training. It's a comprehensive video course that complements what we'll cover in this module. The course is taught by experienced instructors and covers topics from basic syntax to advanced patterns. You'll see real-world coding examples and can follow along at your own pace. LinkedIn Learning is free through many universities and libraries. I suggest watching the videos alongside our slides - they reinforce each other well. The hands-on exercises in the course are particularly valuable for building muscle memory with JavaScript syntax.">
            <div class="dark-container">
                <h2>Recommended Resource</h2>
                <p class="subtitle">Free video training to supplement your JavaScript learning journey</p>
                <a href="https://www.linkedin.com/learning/javascript-essential-training" target="_blank" rel="noopener" class="video-thumbnail">
                    <div style="background: linear-gradient(135deg, #f7df1e 0%, #d4b800 100%); padding: 3rem 2rem; text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">JS</div>
                        <div style="font-size: 1.5rem; font-weight: 600; color: #1a1a1a;">JavaScript</div>
                        <div style="font-size: 1rem; color: #333;">Essential Training</div>
                    </div>
                    <div class="video-info">
                        <span class="linkedin-logo">in</span>
                        <span class="video-title">JavaScript Essential Training</span>
                        <span class="video-meta">LinkedIn Learning</span>
                    </div>
                </a>
                <p style="text-align: center; margin-top: 1rem; font-size: 0.9rem;">Click to open in a new tab</p>
            </div>
        </section>

        <!-- Part 1 Title -->
        <section class="slide title-slide" id="part1" data-narration="Let's start with Part 1, exploring the history and origins of JavaScript. Understanding where JavaScript came from helps us appreciate its quirks and design decisions. Many of JavaScript's unusual behaviors - like type coercion, loose equality, and hoisting - make more sense when you know it was created in just 10 days. We'll also cover the browser wars, ECMAScript standardization, and Node.js revolution. This historical context isn't just trivia - it explains why JavaScript code written 20 years ago still runs today, and why certain patterns became best practices. Knowing this history makes you a more informed developer.">
            <h1>Part 1</h1>
            <p class="subtitle">JavaScript History & Origins</p>
        </section>

        <!-- Slide 3: 10 Days -->
        <section class="slide" id="js-creation" data-narration="JavaScript was created in just 10 days by Brendan Eich at Netscape in 1995. This incredibly short development timeline explains many of JavaScript's quirks and unusual behaviors. Netscape needed a scripting language for their browser immediately to compete with Microsoft. Eich drew inspiration from Scheme (functional programming), Self (prototypes), and Java (syntax). The time pressure meant some decisions were made hastily - like automatic semicolon insertion and loose type coercion. Despite these quirks, the core design was solid enough that we're still using JavaScript 30 years later. It's a testament to Eich's skill that a 10-day prototype became the world's most-used programming language.">
            <div class="dark-container">
                <h2>The Birth of JavaScript</h2>
                <p class="subtitle">JavaScript was created in just 10 days under intense deadline pressure, which explains many of its quirks.</p>
                <div style="text-align: center; margin: 2rem 0;">
                    <div class="big-number">10</div>
                    <div class="stat-label">Days to Create JavaScript</div>
                </div>
                <p style="text-align: center;">Brendan Eich at Netscape, May 1995</p>
            </div>
        </section>

        <!-- Slide 4: Original Names -->
        <section class="slide" id="js-names" data-narration="JavaScript went through several name changes. It started as Mocha, became LiveScript, and was finally renamed JavaScript as a marketing strategy to capitalize on Java's popularity. The name 'JavaScript' has caused endless confusion - it has almost nothing to do with Java! The naming was a pure marketing decision during a time when Java was the hot new technology. Sun Microsystems (Java's creator) actually licensed the name to Netscape. This marketing legacy still confuses beginners today. Remember: JavaScript is to Java as hamburger is to ham - the name is misleading. The languages have different syntax, different paradigms, and different use cases.">
            <div class="dark-container">
                <h2>What's in a Name?</h2>
                <p class="subtitle">JavaScript's name was a marketing decision, not a technical one - it's unrelated to Java.</p>
                <div class="flow-diagram">
                    <div class="flow-box">
                        <div class="label">1995</div>
                        <div class="value">Mocha</div>
                    </div>
                    <div class="flow-arrow">&rarr;</div>
                    <div class="flow-box">
                        <div class="label">1995</div>
                        <div class="value">LiveScript</div>
                    </div>
                    <div class="flow-arrow">&rarr;</div>
                    <div class="flow-box highlight">
                        <div class="label">Dec 1995</div>
                        <div class="value">JavaScript</div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 1rem;">Named for marketing synergy with Java (despite being unrelated)</p>
            </div>
        </section>

        <!-- Slide 5: Browser Wars -->
        <section class="slide" id="browser-wars" data-narration="The browser wars between Netscape and Microsoft created competing JavaScript implementations. Microsoft's JScript was similar but not identical, leading to compatibility nightmares for developers. Microsoft reverse-engineered JavaScript to create JScript for Internet Explorer, but added their own proprietary features. Developers had to write separate code paths for each browser, often using 'browser sniffing' to detect which browser was running. This era gave us infamous patterns like 'document.all' for IE and 'document.layers' for Netscape. The pain of this period directly led to the push for web standards. Libraries like jQuery later emerged specifically to smooth over these browser differences. Understanding this history explains why web standards matter so much today.">
            <div class="dark-container">
                <h2>The Browser Wars</h2>
                <p class="subtitle">Competing browser implementations created compatibility nightmares that shaped modern web standards.</p>
                <div class="dark-two-column">
                    <div class="dark-card">
                        <h4>Netscape Navigator</h4>
                        <p>JavaScript (original)</p>
                        <p style="margin-top: 0.5rem; color: #2dd4bf;">First mover advantage</p>
                    </div>
                    <div class="dark-card">
                        <h4>Internet Explorer</h4>
                        <p>JScript (Microsoft's version)</p>
                        <p style="margin-top: 0.5rem; color: #facc15;">Similar but incompatible</p>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 1.5rem; color: #f87171;">Result: "Best viewed in..." badges everywhere</p>
            </div>
        </section>

        <!-- Slide 6: ECMAScript -->
        <section class="slide" id="ecmascript" data-narration="To bring order to the chaos, JavaScript was standardized as ECMAScript by ECMA International in 1997. ECMAScript is the official specification that JavaScript implements. ECMA-262 is the formal document that defines the language's syntax and behavior. The TC39 committee, made up of browser vendors and JavaScript experts, meets regularly to evolve the language. New features go through a multi-stage proposal process before being added to the spec. This careful process ensures backwards compatibility - code written decades ago still works. When you hear 'ES6' or 'ES2015', that refers to specific versions of this specification. Understanding ECMAScript helps you know which features are universally supported vs. which need transpilation.">
            <div class="dark-container">
                <h2>ECMAScript: The Standard</h2>
                <p class="subtitle">ECMAScript is the official specification that defines JavaScript's syntax and behavior.</p>
                <div class="feature-grid" style="margin-top: 1.5rem;">
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>ECMA-262</strong>
                            Official language specification
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>TC39 Committee</strong>
                            Manages language evolution
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Yearly Releases</strong>
                            ES2015, ES2016, ES2017...
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Browser Vendors</strong>
                            Implement the standard
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 7: ES Version Timeline -->
        <section class="slide" id="es-versions" data-narration="Here's a timeline of major ECMAScript versions. ES3 in 1999 was widely adopted, ES5 in 2009 added strict mode, and ES6 in 2015 was a massive update that modernized the language. ES4 was actually abandoned due to scope creep and disagreements over ambitious rewrites. The 10-year gap between ES3 and ES5 led to stagnation, but ES6 brought the language into the modern era with classes, modules, arrow functions, let/const, and much more. Since ES2016, we get smaller yearly updates instead of massive releases. Each version is fully backwards compatible, so you can mix old and new syntax. Tools like Babel can transpile newer syntax to older versions for browser compatibility.">
            <div class="dark-container">
                <h2>ECMAScript Evolution</h2>
                <p class="subtitle">From ES3 to modern yearly releases - how JavaScript's specification has evolved over time.</p>
                <div class="timeline" style="margin-top: 1.5rem;">
                    <div class="timeline-item">
                        <div class="timeline-year">ES3 (1999)</div>
                        <div class="timeline-content">Regular expressions, try/catch - widely adopted baseline</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">ES5 (2009)</div>
                        <div class="timeline-content">Strict mode, JSON, Array methods - 10 years of refinement</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">ES6/ES2015</div>
                        <div class="timeline-content">Classes, modules, arrow functions, let/const - modern JS begins</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">ES2016+</div>
                        <div class="timeline-content">Yearly releases: async/await, spread, optional chaining...</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Node.js Revolution -->
        <section class="slide" id="nodejs" data-narration="In 2009, Node.js changed everything by bringing JavaScript to the server. Built on Chrome's V8 engine, it enabled full-stack JavaScript development and spawned a massive ecosystem. Ryan Dahl created Node.js to solve the 'C10K problem' - handling 10,000+ concurrent connections. Its event-driven, non-blocking architecture made it ideal for I/O-heavy applications like APIs and real-time apps. Node brought us npm, now the world's largest software registry with over 3.5 million packages. This enabled modern build tools like webpack, esbuild, and Vite. Node.js means you can use JavaScript for frontend, backend, CLI tools, desktop apps, and more. It's why 'full-stack JavaScript developer' is now a viable career path.">
            <div class="dark-container">
                <h2>Node.js: JavaScript Everywhere</h2>
                <p class="subtitle">Node.js brought JavaScript to the server, enabling full-stack development with one language.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div>
                        <h3>What Node.js Enabled</h3>
                        <ul>
                            <li><strong>Server-side JavaScript</strong></li>
                            <li><strong>npm</strong> - package ecosystem</li>
                            <li><strong>Build tools</strong> - webpack, etc.</li>
                            <li><strong>Full-stack JS</strong> development</li>
                        </ul>
                    </div>
                    <div>
                        <h3>Built On</h3>
                        <ul>
                            <li>Chrome's <strong>V8 engine</strong></li>
                            <li><strong>Event-driven</strong> architecture</li>
                            <li><strong>Non-blocking</strong> I/O</li>
                            <li><strong>Single-threaded</strong> event loop</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 9: JS vs Java -->
        <section class="slide" id="js-vs-java" data-narration="A common confusion: JavaScript and Java are completely different languages. They share a name for marketing reasons only. Java is statically typed and compiled, JavaScript is dynamic and interpreted. Java requires you to declare types for every variable; JavaScript figures out types at runtime. Java uses classical inheritance with classes; JavaScript uses prototype-based inheritance (though ES6 added class syntax as syntactic sugar). Java runs on the JVM and is popular for enterprise backends and Android apps. JavaScript runs in browsers and Node.js, dominating web development. The only real similarity is some C-like syntax with curly braces and semicolons. Don't let the name confuse you - they're as different as car and carpet!">
            <div class="dark-container">
                <h2>JavaScript vs Java</h2>
                <p class="subtitle">Despite the similar name, JavaScript and Java are completely different programming languages.</p>
                <table class="dark-table">
                    <tr>
                        <th>JavaScript</th>
                        <th>Java</th>
                    </tr>
                    <tr>
                        <td>Dynamic typing</td>
                        <td>Static typing</td>
                    </tr>
                    <tr>
                        <td>Interpreted/JIT</td>
                        <td>Compiled to bytecode</td>
                    </tr>
                    <tr>
                        <td>Prototype-based</td>
                        <td>Class-based</td>
                    </tr>
                    <tr>
                        <td>Browser + Node.js</td>
                        <td>JVM everywhere</td>
                    </tr>
                </table>
            </div>
        </section>

        <!-- Slide 10: Modern JS Stats -->
        <section class="slide" id="js-stats" data-narration="Today, JavaScript is the most popular programming language in the world. It powers 98% of websites and has millions of npm packages. Understanding JavaScript is essential for web development. JavaScript has topped the Stack Overflow Developer Survey as the most-used language for over a decade. The npm registry hosts over 3.5 million packages, dwarfing every other package ecosystem. Every major tech company uses JavaScript extensively - from Google and Facebook to Netflix and Amazon. Even if you specialize in backend or mobile, you'll encounter JavaScript.  JavaScript skills are highly marketable and transferable.">
            <div class="dark-container">
                <h2>JavaScript Today</h2>
                <p class="subtitle">JavaScript is the world's most popular programming language with an unmatched ecosystem.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem; text-align: center;">
                    <div>
                        <div class="big-number" style="font-size: 3rem;">98%</div>
                        <div class="stat-label">of websites use JS</div>
                    </div>
                    <div>
                        <div class="big-number" style="font-size: 3rem;">#1</div>
                        <div class="stat-label">most popular language</div>
                    </div>
                    <div>
                        <div class="big-number" style="font-size: 3rem;">3.5M+</div>
                        <div class="stat-label">npm packages</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 11: Why JS Quirks -->
        <section class="slide" id="js-quirks" data-narration="JavaScript has many quirks because of its rushed creation and backward compatibility requirements. Understanding these helps you avoid common pitfalls. Type coercion can produce surprising results like '5' - 3 equaling 2 while '5' + 3 equals '53'. Variables declared with var are hoisted and function-scoped, leading to unexpected behavior. The this keyword behaves differently depending on how a function is called. Forgetting var/let/const creates global variables accidentally. These aren't bugs - they're features from 1995 that can't be removed without breaking existing websites. Modern JavaScript practices (strict mode, const/let, arrow functions) help you avoid these traps.">
            <div class="dark-container">
                <h2>Why the Quirks?</h2>
                <p class="subtitle">JavaScript's unusual behaviors come from its rushed creation and strict backwards compatibility.</p>
                <div class="dark-two-column" style="margin-top: 1.5rem;">
                    <div class="dark-card warning">
                        <h4>10-Day Development</h4>
                        <p>Rapid prototyping led to inconsistencies</p>
                    </div>
                    <div class="dark-card warning">
                        <h4>Backward Compatibility</h4>
                        <p>Can't break existing websites</p>
                    </div>
                    <div class="dark-card warning">
                        <h4>Type Coercion</h4>
                        <p>Automatic conversions cause surprises</p>
                    </div>
                    <div class="dark-card warning">
                        <h4>Global by Default</h4>
                        <p>Variables leak without var/let/const</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 12: Running JS -->
        <section class="slide" id="running-js" data-narration="You can run JavaScript in multiple environments: browser console for quick tests, script tags in HTML, Node.js for server-side, or online playgrounds for experimentation. The browser console (F12 or right-click Inspect) is perfect for testing snippets and debugging.  Node.js lets you run JavaScript files from the terminal with 'node filename.js'. Online tools like CodePen and JSFiddle are great for sharing code examples and experimenting without local setup. As you learn, I recommend keeping a browser console open to test code as you go. Immediate feedback accelerates learning dramatically.">
            <div class="dark-container">
                <h2>Where JavaScript Runs</h2>
                <p class="subtitle">JavaScript can execute in browsers, on servers, or in online playgrounds.</p>
                <div class="dark-four-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Browser Console</h4>
                        <p>F12 &rarr; Console tab</p>
                    </div>
                    <div class="dark-card">
                        <h4>HTML Script Tag</h4>
                        <p>&lt;script&gt; in pages</p>
                    </div>
                    <div class="dark-card">
                        <h4>Node.js</h4>
                        <p>node file.js</p>
                    </div>
                    <div class="dark-card">
                        <h4>Online</h4>
                        <p>CodePen, JSFiddle</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 13: Console Methods -->
        <section class="slide" id="console-methods" data-narration="The console object provides various methods for debugging. console.log is most common, but console.table, console.time, and console.group are extremely useful for development.">
            <div class="dark-container">
                <h2>Console Methods</h2>
                <p class="subtitle">The console provides essential debugging tools beyond just console.log.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="function">console</span>.<span class="function">log</span>(<span class="string">'Basic output'</span>);
<span class="function">console</span>.<span class="function">error</span>(<span class="string">'Error message'</span>);
<span class="function">console</span>.<span class="function">warn</span>(<span class="string">'Warning message'</span>);
<span class="function">console</span>.<span class="function">table</span>([{<span class="string">name</span>: <span class="string">'Alice'</span>}, {<span class="string">name</span>: <span class="string">'Bob'</span>}]);
<span class="function">console</span>.<span class="function">time</span>(<span class="string">'timer'</span>);
<span class="comment">// ... code to measure ...</span>
<span class="function">console</span>.<span class="function">timeEnd</span>(<span class="string">'timer'</span>);</pre>
                </div>
            </div>
        </section>

        <!-- Slide 14: Script Loading -->
        <section class="slide" id="script-loading" data-narration="When including JavaScript in HTML, script placement matters.  By default, the browser stops parsing HTML when it encounters a script tag, downloads the script, executes it, then continues parsing. This blocking behavior can make pages feel slow. Placing scripts at the end of body ensures the DOM is ready before scripts run. The defer attribute tells the browser to download in parallel and execute after HTML parsing completes. The async attribute downloads in parallel but executes immediately when ready - useful for analytics scripts. For modern development, defer is usually the best choice.">
            <div class="dark-container">
                <h2>Script Loading Strategies</h2>
                <p class="subtitle">Where and how you load scripts affects page performance significantly.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">&lt;!-- Blocks rendering (avoid) --&gt;</span>
&lt;<span class="keyword">head</span>&gt;
  &lt;<span class="keyword">script</span> <span class="function">src</span>=<span class="string">"app.js"</span>&gt;&lt;/<span class="keyword">script</span>&gt;
&lt;/<span class="keyword">head</span>&gt;

<span class="comment">&lt;!-- Better: defer or end of body --&gt;</span>
&lt;<span class="keyword">script</span> <span class="function">src</span>=<span class="string">"app.js"</span> <span class="function">defer</span>&gt;&lt;/<span class="keyword">script</span>&gt;

<span class="comment">&lt;!-- Or place before &lt;/body&gt; --&gt;</span>
&lt;<span class="keyword">body</span>&gt;
  <span class="comment">&lt;!-- content --&gt;</span>
  &lt;<span class="keyword">script</span> <span class="function">src</span>=<span class="string">"app.js"</span>&gt;&lt;/<span class="keyword">script</span>&gt;
&lt;/<span class="keyword">body</span>&gt;</pre>
                </div>
            </div>
        </section>

        <!-- Slide 15: Part 1 Summary -->
        <section class="slide" id="part1-summary" data-narration="To summarize Part 1: JavaScript was created quickly in 1995, standardized as ECMAScript, and revolutionized by Node.js. Its quirks come from history, not poor design.  The browser wars created compatibility chaos until ECMAScript standardization brought order. ES6 in 2015 modernized the language dramatically, and yearly releases keep it evolving. Node.js enabled full-stack JavaScript development and gave us npm. Understanding this history helps you appreciate why JavaScript is the way it is and why certain patterns became best practices.">
            <div class="dark-container">
                <h2>Part 1 Summary</h2>
                <p class="subtitle">Key takeaways from JavaScript's history and origins.</p>
                <div class="feature-grid" style="margin-top: 1.5rem;">
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Created in 10 days</strong>
                            Brendan Eich, Netscape, 1995
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Standardized as ECMAScript</strong>
                            TC39 committee manages evolution
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Node.js (2009)</strong>
                            Enabled server-side JavaScript
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">&#10003;</span>
                        <div class="feature-text">
                            <strong>Most popular language</strong>
                            Powers 98% of websites
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== PART 2: JavaScript Fundamentals (Slides 16-54) ========== -->

        <!-- Slide 16: Part 2 Title -->
        <section class="slide title-slide" id="part2" data-narration="Part 2 covers JavaScript fundamentals - the core building blocks you'll use every day. We'll cover variables, types, operators, functions, and working with the DOM. This is the heart of the module where you'll learn to write actual JavaScript code. We'll start with variables and how to store data, then explore JavaScript's type system and its quirks. You'll learn about operators, control flow, functions, and array methods. Each concept builds on the previous ones. Pay special attention to the code examples - try running them in your browser console as we go. By the end of Part 2, you'll have the vocabulary and syntax to read and write basic JavaScript programs.">
            <h1>Part 2</h1>
            <p class="subtitle">JavaScript Fundamentals</p>
        </section>

        <!-- Slide 17: Variable Declaration -->
        <section class="slide" id="variables" data-narration="Modern JavaScript has three ways to declare variables: var, let, and const. Always prefer const for values that don't change, and let when reassignment is needed. Avoid var. var was the original way to declare variables but has problematic scoping rules - it's function-scoped rather than block-scoped. let and const (introduced in ES6) are block-scoped, meaning they only exist within their containing curly braces. const prevents reassignment but doesn't make objects immutable - you can still modify properties. The convention is: use const by default, switch to let only when you need to reassign. This makes your code's intent clearer and helps catch accidental reassignments.">
            <div class="dark-container">
                <h2>Variable Declaration</h2>
                <p class="subtitle">Use const by default, let when reassignment is needed, and avoid var.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">var</span> oldWay = <span class="string">'avoid this'</span>;    <span class="comment">// function scoped, hoisted</span>
<span class="keyword">let</span> canChange = <span class="string">'reassignable'</span>; <span class="comment">// block scoped</span>
<span class="keyword">const</span> fixed = <span class="string">'immutable ref'</span>;  <span class="comment">// block scoped, can't reassign</span>

<span class="comment">// Best practice: const by default, let when needed</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 18: var vs let vs const Table -->
        <section class="slide" id="var-let-const" data-narration="Here's a comparison of the three declaration keywords. The key differences are scope, hoisting behavior, and whether you can reassign or redeclare the variable. Scope determines where a variable is accessible - var is function-scoped while let/const are block-scoped. Hoisting means declarations are moved to the top of their scope, but let/const create a 'temporal dead zone' where accessing them before declaration throws an error. var allows redeclaration which can hide bugs. The TDZ (Temporal Dead Zone) is actually helpful - it catches the common mistake of using a variable before declaring it. Study this table carefully as it's a common interview question.">
            <div class="dark-container">
                <h2>Declaration Comparison</h2>
                <p class="subtitle">Understanding the key differences between var, let, and const.</p>
                <table class="dark-table">
                    <tr>
                        <th>Feature</th>
                        <th><code>var</code></th>
                        <th><code>let</code></th>
                        <th><code>const</code></th>
                    </tr>
                    <tr>
                        <td>Scope</td>
                        <td>Function</td>
                        <td>Block</td>
                        <td>Block</td>
                    </tr>
                    <tr>
                        <td>Hoisting</td>
                        <td>Yes (undefined)</td>
                        <td>TDZ</td>
                        <td>TDZ</td>
                    </tr>
                    <tr>
                        <td>Reassign</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Redeclare</td>
                        <td>Yes</td>
                        <td>No</td>
                        <td>No</td>
                    </tr>
                </table>
                <p style="margin-top: 1rem; font-size: 0.9rem;">TDZ = Temporal Dead Zone (error if accessed before declaration)</p>
            </div>
        </section>

        <!-- Slide 19: Primitive Types -->
        <section class="slide" id="primitive-types" data-narration="JavaScript has 7 primitive types. These are immutable values stored directly in memory. String, number, boolean, null, undefined, symbol, and bigint. Primitives are passed by value - when you assign a primitive to another variable, it copies the value. This is different from objects which are passed by reference. null represents intentional absence of a value while undefined means a variable was declared but never assigned. symbol creates unique identifiers (useful for object keys), and bigint handles integers larger than Number.MAX_SAFE_INTEGER. Note that 'object' isn't a primitive - it's a reference type that includes arrays, functions, and regular objects.">
            <div class="dark-container">
                <h2>Primitive Types</h2>
                <p class="subtitle">JavaScript has 7 primitive types that are immutable and passed by value.</p>
                <div class="dark-four-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>string</h4>
                        <p><code>"hello"</code></p>
                    </div>
                    <div class="dark-card">
                        <h4>number</h4>
                        <p><code>42</code>, <code>3.14</code></p>
                    </div>
                    <div class="dark-card">
                        <h4>boolean</h4>
                        <p><code>true</code>, <code>false</code></p>
                    </div>
                    <div class="dark-card">
                        <h4>null</h4>
                        <p>intentional empty</p>
                    </div>
                    <div class="dark-card">
                        <h4>undefined</h4>
                        <p>unassigned</p>
                    </div>
                    <div class="dark-card">
                        <h4>symbol</h4>
                        <p>unique identifier</p>
                    </div>
                    <div class="dark-card">
                        <h4>bigint</h4>
                        <p>large integers</p>
                    </div>
                    <div class="dark-card info">
                        <h4>object</h4>
                        <p>reference type</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 20: typeof Operator -->
        <section class="slide" id="typeof" data-narration="The typeof operator returns the type of a value as a string. Watch out for the quirk where typeof null returns 'object' - this is a historical bug that can't be fixed. This bug dates back to JavaScript's first implementation where values were stored with type tags, and null used the object tag. typeof also returns 'object' for arrays since arrays are technically objects in JavaScript - use Array.isArray() to check for arrays specifically. Notice that typeof function returns 'function' even though functions are objects. typeof is useful for checking if a variable is defined: typeof x !== 'undefined'. Understanding these quirks helps you avoid common debugging pitfalls.">
            <div class="dark-container">
                <h2>The typeof Operator</h2>
                <p class="subtitle">typeof returns a string indicating the type, but has some quirks to be aware of.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">typeof</span> <span class="string">"hello"</span>    <span class="comment">// "string"</span>
<span class="keyword">typeof</span> <span class="number">42</span>         <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="keyword">true</span>       <span class="comment">// "boolean"</span>
<span class="keyword">typeof</span> <span class="keyword">undefined</span>  <span class="comment">// "undefined"</span>
<span class="keyword">typeof</span> <span class="keyword">null</span>       <span class="comment">// "object" - historical bug!</span>
<span class="keyword">typeof</span> {}         <span class="comment">// "object"</span>
<span class="keyword">typeof</span> []         <span class="comment">// "object" (arrays are objects)</span>
<span class="keyword">typeof</span> <span class="keyword">function</span>(){} <span class="comment">// "function"</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 21: Type Coercion -->
        <section class="slide" id="type-coercion" data-narration="JavaScript automatically converts types when comparing or combining values. This can lead to surprising results. Use strict equality to avoid these issues. The + operator is especially tricky: with a string, it concatenates; with numbers, it adds. Other operators like minus always convert to numbers. The rules for coercion are complex - for example, [] becomes empty string, which becomes 0 when converted to number. Rather than memorizing all the rules, the best practice is to avoid implicit coercion. Use explicit conversions like Number(), String(), or Boolean() when you need to convert types. This makes your code's intent clear and prevents surprises.">
            <div class="dark-container">
                <h2>Type Coercion</h2>
                <p class="subtitle">JavaScript automatically converts types, leading to surprising results if you're not careful.</p>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div class="code-block">
<pre><span class="comment">// Surprising coercions</span>
<span class="string">"5"</span> + <span class="number">3</span>      <span class="comment">// "53" (string)</span>
<span class="string">"5"</span> - <span class="number">3</span>      <span class="comment">// 2 (number)</span>
<span class="string">"5"</span> * <span class="string">"2"</span>    <span class="comment">// 10 (number)</span>
<span class="keyword">true</span> + <span class="keyword">true</span>  <span class="comment">// 2</span>
[] + {}      <span class="comment">// "[object Object]"</span></pre>
                    </div>
                    <div class="dark-card warning">
                        <h4>Avoid with</h4>
                        <p>Use <code>===</code> strict equality</p>
                        <p style="margin-top: 0.5rem;">Explicit: <code>Number()</code>, <code>String()</code></p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 22: Equality Operators -->
        <section class="slide" id="equality" data-narration="Always use strict equality with triple equals. Double equals performs type coercion which leads to confusing behavior like empty string equaling zero. The double equals operator converts operands to the same type before comparing, following complex rules. This is why '5' == 5 is true (string becomes number), and 0 == false is true (false becomes 0). Triple equals compares both value AND type without any conversion. The only exception where == is acceptable: checking for null or undefined with 'x == null' catches both. ESLint and other linters will warn you about using loose equality. Make strict equality your default and your code will be more predictable.">
            <div class="dark-container">
                <h2>Equality: == vs ===</h2>
                <p class="subtitle">Always use strict equality (===) to avoid type coercion surprises.</p>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div>
                        <h3 style="color: #f87171;">== (Loose)</h3>
                        <div class="code-block">
<pre><span class="string">"5"</span> == <span class="number">5</span>     <span class="comment">// true</span>
<span class="number">0</span> == <span class="keyword">false</span>   <span class="comment">// true</span>
<span class="keyword">null</span> == <span class="keyword">undefined</span> <span class="comment">// true</span>
<span class="string">""</span> == <span class="number">0</span>      <span class="comment">// true</span></pre>
                        </div>
                    </div>
                    <div>
                        <h3 style="color: #4ade80;">=== (Strict)</h3>
                        <div class="code-block">
<pre><span class="string">"5"</span> === <span class="number">5</span>    <span class="comment">// false</span>
<span class="number">0</span> === <span class="keyword">false</span>  <span class="comment">// false</span>
<span class="keyword">null</span> === <span class="keyword">undefined</span> <span class="comment">// false</span>
<span class="string">""</span> === <span class="number">0</span>     <span class="comment">// false</span></pre>
                        </div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 1rem; color: #4ade80;">Always use === unless you have a specific reason</p>
            </div>
        </section>

        <!-- Slide 23: Truthy and Falsy -->
        <section class="slide" id="truthy-falsy" data-narration="In boolean contexts, JavaScript treats certain values as false: false, 0, empty string, null, undefined, and NaN. Everything else is truthy, including empty arrays and objects. This matters because conditionals like if(value) convert values to boolean implicitly. A common gotcha: empty array [] and empty object {} are truthy! To check if an array is empty, use array.length === 0. The six falsy values are worth memorizing. You can use double negation (!!) to explicitly convert any value to boolean. Understanding truthy/falsy is essential for writing concise conditionals and using the logical AND/OR operators for default values and short-circuit evaluation.">
            <div class="dark-container">
                <h2>Truthy &amp; Falsy Values</h2>
                <p class="subtitle">JavaScript converts values to boolean in conditionals - know which values are falsy.</p>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div>
                        <h3 style="color: #f87171;">Falsy (6 values)</h3>
                        <div class="code-block">
<pre><span class="keyword">false</span>
<span class="number">0</span> <span class="comment">(and -0, 0n)</span>
<span class="string">""</span> <span class="comment">(empty string)</span>
<span class="keyword">null</span>
<span class="keyword">undefined</span>
<span class="number">NaN</span></pre>
                        </div>
                    </div>
                    <div>
                        <h3 style="color: #4ade80;">Truthy (everything else)</h3>
                        <div class="code-block">
<pre><span class="keyword">true</span>
<span class="number">42</span> <span class="comment">(any non-zero number)</span>
<span class="string">"hello"</span> <span class="comment">(non-empty string)</span>
[] <span class="comment">(empty array!)</span>
{} <span class="comment">(empty object!)</span>
<span class="keyword">function</span>() {}</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 24: Strings -->
        <section class="slide" id="strings" data-narration="Strings can be created with single quotes, double quotes, or backticks. Backticks enable template literals which support multi-line strings and embedded expressions. Single and double quotes are functionally identical - pick a convention and stick with it. Template literals (backticks) are the most powerful: they allow string interpolation with ${expression}, can span multiple lines without escape characters, and can even be used with tagged template functions for custom processing. When embedding variables or expressions in strings, always prefer template literals over concatenation with +. They're more readable and less error-prone.">
            <div class="dark-container">
                <h2>Strings</h2>
                <p class="subtitle">Use template literals (backticks) for strings with variables or multiple lines.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> single = <span class="string">'Hello'</span>;
<span class="keyword">const</span> double = <span class="string">"World"</span>;
<span class="keyword">const</span> template = <span class="string">`Hello, ${name}!`</span>;

<span class="comment">// Template literals support:</span>
<span class="keyword">const</span> multiline = <span class="string">`
  Line 1
  Line 2
`</span>;

<span class="keyword">const</span> expression = <span class="string">`Result: ${2 + 2}`</span>; <span class="comment">// "Result: 4"</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 25: String Methods -->
        <section class="slide" id="string-methods" data-narration="Strings have many built-in methods. Remember that strings are immutable - these methods return new strings rather than modifying the original. toUpperCase() and toLowerCase() are great for case-insensitive comparisons. includes(), startsWith(), and endsWith() return booleans for checking content. slice() extracts portions using start and end indices. split() converts a string to an array based on a delimiter. trim() removes whitespace from both ends. These methods can be chained together since each returns a new string. Always remember: str.toUpperCase() doesn't change str - you need to assign the result back if you want to keep it.">
            <div class="dark-container">
                <h2>String Methods</h2>
                <p class="subtitle">Strings are immutable - methods return new strings without modifying the original.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> str = <span class="string">"Hello, World!"</span>;

str.<span class="function">length</span>              <span class="comment">// 13</span>
str.<span class="function">toUpperCase</span>()       <span class="comment">// "HELLO, WORLD!"</span>
str.<span class="function">toLowerCase</span>()       <span class="comment">// "hello, world!"</span>
str.<span class="function">includes</span>(<span class="string">"World"</span>)  <span class="comment">// true</span>
str.<span class="function">startsWith</span>(<span class="string">"Hello"</span>) <span class="comment">// true</span>
str.<span class="function">slice</span>(<span class="number">0</span>, <span class="number">5</span>)         <span class="comment">// "Hello"</span>
str.<span class="function">split</span>(<span class="string">", "</span>)         <span class="comment">// ["Hello", "World!"]</span>
str.<span class="function">trim</span>()              <span class="comment">// removes whitespace</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 26: Arrays -->
        <section class="slide" id="arrays" data-narration="Arrays are ordered collections that can hold any type of value. They're zero-indexed and have a length property. Unlike typed languages, JavaScript arrays can hold mixed types - strings, numbers, objects, even other arrays. Access elements using bracket notation with the index (starting at 0). The length property tells you how many elements are in the array. Arrays are objects under the hood, which is why typeof [] returns 'object'. Use Array.isArray() to check if something is an array. Arrays are reference types, so assigning an array to a new variable creates a reference, not a copy. We'll cover array methods in detail shortly.">
            <div class="dark-container">
                <h2>Arrays</h2>
                <p class="subtitle">Arrays are ordered, zero-indexed collections that can hold any type of value.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Creating arrays</span>
<span class="keyword">const</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cherry'</span>];
<span class="keyword">const</span> mixed = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="keyword">true</span>, { <span class="string">key</span>: <span class="string">'value'</span> }];

<span class="comment">// Accessing elements (zero-indexed)</span>
fruits[<span class="number">0</span>]        <span class="comment">// 'apple'</span>
fruits[<span class="number">2</span>]        <span class="comment">// 'cherry'</span>
fruits.<span class="function">length</span>    <span class="comment">// 3</span>
fruits.<span class="function">at</span>(<span class="number">-1</span>)    <span class="comment">// 'cherry' (last element)</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 27: Array Methods -->
        <section class="slide" id="array-methods" data-narration="Arrays have powerful built-in methods. Push and pop work on the end, shift and unshift on the beginning. push() adds to the end and returns the new length. pop() removes from the end and returns the removed element. unshift() adds to the beginning, shift() removes from the beginning. These are mutating methods - they modify the original array. indexOf() returns the position of an element (-1 if not found). includes() returns true/false for membership. find() returns the first element matching a callback. These methods are the bread and butter of array manipulation.">
            <div class="dark-container">
                <h2>Array Methods</h2>
                <p class="subtitle">Core methods for adding, removing, and finding array elements.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="comment">// Add/Remove</span>
arr.<span class="function">push</span>(<span class="number">4</span>)       <span class="comment">// [1, 2, 3, 4] - add to end</span>
arr.<span class="function">pop</span>()         <span class="comment">// returns 4, arr = [1, 2, 3]</span>
arr.<span class="function">unshift</span>(<span class="number">0</span>)    <span class="comment">// [0, 1, 2, 3] - add to start</span>
arr.<span class="function">shift</span>()       <span class="comment">// returns 0, arr = [1, 2, 3]</span>

<span class="comment">// Find</span>
arr.<span class="function">indexOf</span>(<span class="number">2</span>)    <span class="comment">// 1 (index of value)</span>
arr.<span class="function">includes</span>(<span class="number">2</span>)   <span class="comment">// true</span>
arr.<span class="function">find</span>(x => x > <span class="number">1</span>) <span class="comment">// 2 (first match)</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 28: Array Iteration -->
        <section class="slide" id="array-iteration" data-narration="Modern JavaScript provides powerful iteration methods. forEach for side effects, map for transformation, filter for selection, and reduce for aggregation. map() creates a new array by applying a function to each element - perfect for transformations. filter() creates a new array with elements that pass a test. reduce() accumulates array elements into a single value (sum, object, etc.). forEach() just iterates without returning anything. These methods don't mutate the original array (except forEach side effects). They're chainable: arr.filter(...).map(...).reduce(...). Master these and you'll write cleaner, more declarative code than with traditional loops.">
            <div class="dark-container">
                <h2>Array Iteration Methods</h2>
                <p class="subtitle">Functional methods for transforming, filtering, and reducing arrays.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="comment">// map - transform each element</span>
nums.<span class="function">map</span>(n => n * <span class="number">2</span>)  <span class="comment">// [2, 4, 6, 8, 10]</span>

<span class="comment">// filter - keep matching elements</span>
nums.<span class="function">filter</span>(n => n > <span class="number">2</span>)  <span class="comment">// [3, 4, 5]</span>

<span class="comment">// reduce - accumulate to single value</span>
nums.<span class="function">reduce</span>((sum, n) => sum + n, <span class="number">0</span>)  <span class="comment">// 15</span>

<span class="comment">// forEach - execute for each element</span>
nums.<span class="function">forEach</span>(n => <span class="function">console</span>.<span class="function">log</span>(n));</pre>
                </div>
            </div>
        </section>

        <!-- Slide 29: Objects -->
        <section class="slide" id="objects" data-narration="Objects are collections of key-value pairs. They're the fundamental building block for complex data structures. Objects can contain any type of value including other objects, arrays, and functions (called methods). Use dot notation for simple property names and bracket notation for dynamic keys or special characters. Objects are reference types - assigning an object to another variable creates a reference, not a copy. Methods can access the object using the 'this' keyword. Object shorthand syntax lets you write {name} instead of {name: name}. Almost everything in JavaScript is an object or behaves like one.">
            <div class="dark-container">
                <h2>Objects</h2>
                <p class="subtitle">Objects are collections of key-value pairs, the foundation of complex data structures.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> person = {
  name: <span class="string">'Alice'</span>,
  age: <span class="number">30</span>,
  isStudent: <span class="keyword">false</span>,
  greet() { <span class="keyword">return</span> <span class="string">`Hi, I'm ${this.name}`</span>; }
};

<span class="comment">// Access properties</span>
person.name          <span class="comment">// 'Alice' (dot notation)</span>
person[<span class="string">'age'</span>]        <span class="comment">// 30 (bracket notation)</span>
person.<span class="function">greet</span>()       <span class="comment">// "Hi, I'm Alice"</span>

<span class="comment">// Add/modify</span>
person.email = <span class="string">'alice@example.com'</span>;</pre>
                </div>
            </div>
        </section>

        <!-- Slide 30: Destructuring -->
        <section class="slide" id="destructuring" data-narration="Destructuring lets you extract values from arrays and objects into distinct variables. It makes code cleaner and more readable. For arrays, the order matters - variables are assigned by position. For objects, the variable names must match property names (unless you rename them). The rest operator (...rest) collects remaining elements into a new array or object. You can set default values for missing properties. Destructuring is especially powerful in function parameters - you can extract exactly what you need from objects passed as arguments. This ES6 feature is now used everywhere in modern JavaScript.">
            <div class="dark-container">
                <h2>Destructuring</h2>
                <p class="subtitle">Extract values from arrays and objects into distinct variables for cleaner code.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Array destructuring</span>
<span class="keyword">const</span> [first, second, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="comment">// first = 1, second = 2, rest = [3, 4]</span>

<span class="comment">// Object destructuring</span>
<span class="keyword">const</span> { name, age, city = <span class="string">'Unknown'</span> } = person;

<span class="comment">// Rename while destructuring</span>
<span class="keyword">const</span> { name: userName } = person;

<span class="comment">// Function parameters</span>
<span class="keyword">function</span> <span class="function">greet</span>({ name, age }) {
  <span class="keyword">return</span> <span class="string">`${name} is ${age}`</span>;
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 31: Functions -->
        <section class="slide" id="functions" data-narration="Functions are first-class citizens in JavaScript. You can declare them, assign them to variables, or write them as arrow functions. Function declarations are hoisted - you can call them before they appear in code. Function expressions are not hoisted. Arrow functions (ES6) provide concise syntax and don't have their own 'this' binding. Functions can return values, take parameters with defaults, and use rest parameters for variable arguments. In JavaScript, functions are objects - they can be passed as arguments, returned from other functions, and stored in variables. This enables powerful patterns like callbacks and closures.">
            <div class="dark-container">
                <h2>Functions</h2>
                <p class="subtitle">Functions are first-class citizens - they can be passed around and assigned like any value.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Function declaration (hoisted)</span>
<span class="keyword">function</span> <span class="function">greet</span>(name) {
  <span class="keyword">return</span> <span class="string">`Hello, ${name}!`</span>;
}

<span class="comment">// Function expression</span>
<span class="keyword">const</span> greet = <span class="keyword">function</span>(name) {
  <span class="keyword">return</span> <span class="string">`Hello, ${name}!`</span>;
};

<span class="comment">// Arrow function (ES6)</span>
<span class="keyword">const</span> greet = (name) => <span class="string">`Hello, ${name}!`</span>;</pre>
                </div>
            </div>
        </section>

        <!-- Slide 32: Arrow Functions -->
        <section class="slide" id="arrow-functions" data-narration="Arrow functions provide concise syntax. They also don't have their own this binding. With a single expression, you can omit the return keyword and curly braces for an implicit return. Single parameters don't need parentheses. When returning an object literal, wrap it in parentheses to avoid confusion with a function body. The lack of 'this' binding is crucial - arrow functions inherit 'this' from their enclosing scope, making them perfect for callbacks in event handlers and array methods. This behavior eliminates the common pattern of 'const self = this'. Use arrow functions for most callbacks and short functions.">
            <div class="dark-container">
                <h2>Arrow Functions</h2>
                <p class="subtitle">Concise function syntax that inherits 'this' from surrounding scope.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Full syntax</span>
<span class="keyword">const</span> add = (a, b) => {
  <span class="keyword">return</span> a + b;
};

<span class="comment">// Implicit return (single expression)</span>
<span class="keyword">const</span> add = (a, b) => a + b;

<span class="comment">// Single parameter (no parens needed)</span>
<span class="keyword">const</span> double = x => x * <span class="number">2</span>;

<span class="comment">// Return object (wrap in parens)</span>
<span class="keyword">const</span> makePerson = name => ({ name, age: <span class="number">0</span> });</pre>
                </div>
                <p style="margin-top: 1rem; color: #facc15;">Arrow functions don't have their own <code>this</code></p>
            </div>
        </section>

        <!-- Slide 33: Control Flow -->
        <section class="slide" id="control-flow" data-narration="Control flow determines which code executes and when. The if statement is fundamental - it runs a block of code only when a condition evaluates to truthy. You can chain multiple conditions with else if, and provide a fallback with else for when nothing matches. The condition in parentheses gets converted to boolean, so understanding truthy and falsy values matters here. Always use curly braces even for single statements - it prevents bugs when you add more code later. The ternary operator provides a concise alternative for simple conditional assignments: condition ? valueIfTrue : valueIfFalse. Use if/else for complex logic with multiple statements, and ternary for simple value selection. Notice how the code example checks score ranges - this pattern is common for grading systems and categorization.">
            <div class="dark-container">
                <h2>Control Flow: if/else</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> score = <span class="number">85</span>;

<span class="keyword">if</span> (score >= <span class="number">90</span>) {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'A'</span>);
} <span class="keyword">else if</span> (score >= <span class="number">80</span>) {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'B'</span>);
} <span class="keyword">else if</span> (score >= <span class="number">70</span>) {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'C'</span>);
} <span class="keyword">else</span> {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'F'</span>);
}

<span class="comment">// Ternary operator</span>
<span class="keyword">const</span> result = score >= <span class="number">60</span> ? <span class="string">'Pass'</span> : <span class="string">'Fail'</span>;</pre>
                </div>
            </div>
        </section>

        <!-- Slide 34: Loops -->
        <section class="slide" id="loops" data-narration="JavaScript provides several ways to iterate, and knowing which to use makes your code cleaner. The traditional for loop gives you complete control with initialization, condition, and increment - perfect when you need the index or want non-sequential iteration. The for...of loop introduced in ES6 is ideal for iterating over array values, strings, Maps, Sets, and any iterable - it's cleaner when you just need each value without caring about the index. The for...in loop iterates over object keys (property names), not values - use it for objects, but be aware it includes inherited properties unless you check with hasOwnProperty. While loops are useful when you don't know how many iterations you need upfront. In practice, you'll often use array methods like forEach, map, and filter instead of explicit loops - they're more declarative and less error-prone. Choose the right tool for the job.">
            <div class="dark-container">
                <h2>Loops</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Traditional for loop</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {
  <span class="function">console</span>.<span class="function">log</span>(i);
}

<span class="comment">// for...of (iterate values)</span>
<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) {
  <span class="function">console</span>.<span class="function">log</span>(item);  <span class="comment">// 'a', 'b', 'c'</span>
}

<span class="comment">// for...in (iterate keys)</span>
<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> { a: <span class="number">1</span>, b: <span class="number">2</span> }) {
  <span class="function">console</span>.<span class="function">log</span>(key);  <span class="comment">// 'a', 'b'</span>
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 35: DOM Introduction -->
        <section class="slide" id="dom-intro" data-narration="The Document Object Model represents HTML as a tree of objects. JavaScript can access and manipulate this tree. When the browser loads HTML, it creates a DOM tree with document as the root. Each HTML element becomes a node in this tree with properties and methods. JavaScript can read content, modify elements, add new elements, remove elements, and respond to user interactions. The DOM is what makes web pages interactive. Modern frameworks like React and Vue abstract away direct DOM manipulation, but understanding the DOM is essential for debugging and performance optimization.">
            <div class="dark-container">
                <h2>The DOM</h2>
                <p class="subtitle">The browser's representation of HTML as a tree of objects that JavaScript can manipulate.</p>
                <div class="flow-diagram" style="margin-top: 1.5rem;">
                    <div class="flow-box highlight">
                        <div class="label">HTML</div>
                        <div class="value">document</div>
                    </div>
                    <div class="flow-arrow">&rarr;</div>
                    <div class="flow-box">
                        <div class="label">Parser</div>
                        <div class="value">Browser</div>
                    </div>
                    <div class="flow-arrow">&rarr;</div>
                    <div class="flow-box highlight">
                        <div class="label">Tree</div>
                        <div class="value">DOM</div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 1rem;">JavaScript can read and modify the DOM tree</p>
            </div>
        </section>

        <!-- Slide 36: Selecting Elements -->
        <section class="slide" id="selecting-elements" data-narration="To work with DOM elements, first select them. querySelector uses CSS selectors and returns the first match. querySelector and querySelectorAll are the modern methods - they accept any valid CSS selector. getElementById is faster for ID lookups but less flexible. querySelector returns the first match or null if nothing matches. querySelectorAll returns a NodeList of all matches (use forEach or convert to array). You can call querySelector on any element, not just document, to search within that element's descendants. Always check if querySelector returned null before trying to use the element.">
            <div class="dark-container">
                <h2>Selecting DOM Elements</h2>
                <p class="subtitle">Use querySelector with CSS selectors to find elements in the DOM.</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Modern methods (use CSS selectors)</span>
<span class="keyword">const</span> el = <span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'.my-class'</span>);
<span class="keyword">const</span> els = <span class="function">document</span>.<span class="function">querySelectorAll</span>(<span class="string">'p'</span>);

<span class="comment">// Classic methods</span>
<span class="function">document</span>.<span class="function">getElementById</span>(<span class="string">'myId'</span>)
<span class="function">document</span>.<span class="function">getElementsByClassName</span>(<span class="string">'myClass'</span>)

<span class="comment">// querySelector examples</span>
<span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'#header'</span>)      <span class="comment">// by ID</span>
<span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'.btn.primary'</span>) <span class="comment">// by classes</span>
<span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'[data-id="5"]'</span>) <span class="comment">// by attr</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 37: Modifying Elements -->
        <section class="slide" id="modifying-elements" data-narration="Once you've selected an element, you can modify it in several ways. Use textContent to change text safely - it treats everything as plain text, which prevents XSS security vulnerabilities. Avoid innerHTML unless you're sure the content is safe. For HTML attributes, use setAttribute and getAttribute - this works for data attributes, IDs, and any custom attributes. The classList API is your best friend for managing CSS classes - add(), remove(), and toggle() let you manipulate classes cleanly without string parsing. The toggle method is especially useful for things like showing and hiding elements or switching between themes. Direct style manipulation via element.style sets inline styles, but prefer classes when possible for better maintainability and separation of concerns. Remember that style properties use camelCase in JavaScript - backgroundColor, not background-color.">
            <div class="dark-container">
                <h2>Modifying Elements</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> el = <span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'#myDiv'</span>);

<span class="comment">// Content</span>
el.textContent = <span class="string">'New text'</span>;  <span class="comment">// safe, text only</span>

<span class="comment">// Attributes</span>
el.<span class="function">setAttribute</span>(<span class="string">'data-id'</span>, <span class="string">'123'</span>);
el.<span class="function">getAttribute</span>(<span class="string">'data-id'</span>);

<span class="comment">// Classes</span>
el.classList.<span class="function">add</span>(<span class="string">'active'</span>);
el.classList.<span class="function">remove</span>(<span class="string">'hidden'</span>);
el.classList.<span class="function">toggle</span>(<span class="string">'selected'</span>);

<span class="comment">// Styles</span>
el.style.color = <span class="string">'blue'</span>;</pre>
                </div>
            </div>
        </section>

        <!-- Slide 38: Events -->
        <section class="slide" id="events" data-narration="Events let your code respond to user actions like clicks, keypresses, and form submissions. The browser fires events when things happen - mouse clicks, key presses, page loads, form submissions, and more. You attach event listeners to elements to run code when specific events occur. Common mouse events include click, dblclick, mouseenter, and mouseleave. Keyboard events are keydown and keyup. Form events include submit, change, and input. Understanding events is essential for creating interactive web applications. We'll see how to attach listeners in the next slide.">
            <div class="dark-container">
                <h2>Events</h2>
                <p class="subtitle">Events fire when users interact with the page - clicks, keystrokes, form submissions, etc.</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Mouse</h4>
                        <p>click, dblclick, mouseenter</p>
                    </div>
                    <div class="dark-card">
                        <h4>Keyboard</h4>
                        <p>keydown, keyup</p>
                    </div>
                    <div class="dark-card">
                        <h4>Form</h4>
                        <p>submit, change, input</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 39: Event Listeners -->
        <section class="slide" id="event-listeners" data-narration="The addEventListener method is the modern way to attach event handlers, and you should use it over the older onclick property approach. Unlike setting onclick directly, addEventListener lets you attach multiple handlers to the same event - useful when different parts of your code need to respond to the same action. The callback function receives an event object with useful properties: target is the element that triggered the event, currentTarget is the element the listener is attached to, and type tells you the event name. Use event.preventDefault() to stop the browser's default behavior - this is essential for form submissions where you want to handle data with JavaScript instead of reloading the page. Arrow functions work great here since they inherit 'this' from the surrounding scope. You can also remove listeners with removeEventListener, but you need a reference to the same function - anonymous functions can't be removed later.">
            <div class="dark-container">
                <h2>Event Listeners</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> button = <span class="function">document</span>.<span class="function">querySelector</span>(<span class="string">'#myBtn'</span>);

<span class="comment">// Add event listener</span>
button.<span class="function">addEventListener</span>(<span class="string">'click'</span>, (event) => {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Button clicked!'</span>);
  <span class="function">console</span>.<span class="function">log</span>(event.target);  <span class="comment">// the button</span>
});

<span class="comment">// Prevent default behavior</span>
form.<span class="function">addEventListener</span>(<span class="string">'submit'</span>, (e) => {
  e.<span class="function">preventDefault</span>();  <span class="comment">// prevent page reload</span>
});</pre>
                </div>
            </div>
        </section>

        <!-- Slide 40: Error Handling -->
        <section class="slide" id="error-handling" data-narration="Error handling prevents your application from crashing when things go wrong. The try block wraps code that might throw an error - API calls, JSON parsing, file operations, or any operation that could fail. If an error occurs, execution immediately jumps to the catch block, which receives the error object with message and stack properties for debugging. The finally block always runs regardless of success or failure - use it for cleanup like closing connections or resetting state. You can throw custom errors with 'throw new Error(message)' to signal problems in your own code - this is great for validation. For async/await code, wrap your awaits in try-catch to handle rejected promises. Pro tip: don't catch errors you can't handle meaningfully - sometimes it's better to let them bubble up to a global error handler. During development, always log the full error; in production, show users a friendly message while logging details for debugging.">
            <div class="dark-container">
                <h2>Error Handling</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">try</span> {
  <span class="comment">// Code that might throw an error</span>
  <span class="keyword">const</span> data = <span class="function">JSON</span>.<span class="function">parse</span>(invalidJson);
} <span class="keyword">catch</span> (error) {
  <span class="function">console</span>.<span class="function">error</span>(<span class="string">'Failed:'</span>, error.message);
} <span class="keyword">finally</span> {
  <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Done'</span>);  <span class="comment">// Always runs</span>
}

<span class="comment">// Throw custom errors</span>
<span class="keyword">function</span> <span class="function">divide</span>(a, b) {
  <span class="keyword">if</span> (b === <span class="number">0</span>) <span class="keyword">throw new</span> <span class="function">Error</span>(<span class="string">'Cannot divide by zero'</span>);
  <span class="keyword">return</span> a / b;
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 41: Part 2 Summary -->
        <section class="slide" id="part2-summary" data-narration="Part 2 covered JavaScript fundamentals - the building blocks you'll use every single day as a developer. Variables store your data with const, let, and var. The type system includes primitives and objects, with quirks like type coercion that you now know how to avoid. Arrays and objects organize your data, with powerful methods for manipulation. Functions are first-class citizens - you can pass them around, return them, and use arrow syntax for cleaner code. The DOM lets you select and modify HTML elements programmatically. Events make your pages interactive by responding to user actions. These concepts all connect: you declare variables, store data in arrays and objects, write functions to process them, update the DOM to display results, and use events to trigger the whole cycle. Practice these until they become second nature.">
            <div class="dark-container">
                <h2>Part 2 Summary</h2>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Variables &amp; Types</h4>
                        <p>let/const, primitives</p>
                    </div>
                    <div class="dark-card">
                        <h4>Data Structures</h4>
                        <p>Arrays, objects</p>
                    </div>
                    <div class="dark-card">
                        <h4>Functions</h4>
                        <p>Declarations, arrows</p>
                    </div>
                    <div class="dark-card">
                        <h4>Control Flow</h4>
                        <p>if/else, loops</p>
                    </div>
                    <div class="dark-card">
                        <h4>DOM</h4>
                        <p>Select, modify</p>
                    </div>
                    <div class="dark-card">
                        <h4>Events</h4>
                        <p>Listeners, handling</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== PART 3: Advanced JavaScript (Slides 42-60) ========== -->

        <!-- Slide 42: Part 3 Title -->
        <section class="slide title-slide" id="part3" data-narration="Part 3 covers advanced JavaScript concepts that separate junior developers from senior ones. We'll explore scope and closures for data privacy and function factories. The 'this' keyword is notoriously confusing - we'll demystify how it actually works based on how functions are called. Asynchronous programming with promises and async/await is essential for working with APIs and any operation that takes time. ES6 classes provide familiar object-oriented syntax while still using prototypes under the hood. Modules let you organize code across multiple files with import and export. These topics require more mental effort than Part 2, but mastering them dramatically improves your code quality and opens doors to more complex applications. Take your time with these - they're concepts you'll use throughout your entire career.">
            <h1>Part 3</h1>
            <p class="subtitle">Advanced JavaScript</p>
        </section>

        <!-- Slide 43: Scope -->
        <section class="slide" id="scope" data-narration="Scope determines where variables are accessible in your code, and understanding it prevents countless bugs. Global scope means a variable is available everywhere - avoid this as it leads to naming conflicts and hard-to-track bugs. Function scope (what var uses) means the variable exists throughout the entire function, even before its declaration line due to hoisting. Block scope (what let and const use) limits the variable to the nearest curly braces - an if statement, loop, or standalone block. Look at the code example: const and let stay within their if block, while var leaks out to the whole function. The temporal dead zone is the period between entering a block and hitting the let or const declaration - accessing the variable there throws an error. This is actually helpful because it catches the common mistake of using a variable before initializing it. When debugging weird behavior, scope issues are often the culprit.">
            <div class="dark-container">
                <h2>Scope</h2>
                <p class="subtitle">Where variables are accessible</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> global = <span class="string">'everywhere'</span>;  <span class="comment">// global scope</span>

<span class="keyword">function</span> <span class="function">outer</span>() {
  <span class="keyword">const</span> funcScoped = <span class="string">'function only'</span>;

  <span class="keyword">if</span> (<span class="keyword">true</span>) {
    <span class="keyword">const</span> blockScoped = <span class="string">'block only'</span>;
    <span class="keyword">var</span> notBlockScoped = <span class="string">'leaks out!'</span>;
  }

  <span class="function">console</span>.<span class="function">log</span>(notBlockScoped); <span class="comment">// works (var)</span>
  <span class="comment">// console.log(blockScoped); // Error!</span>
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 44: Closures -->
        <section class="slide" id="closures" data-narration="A closure is a function that remembers variables from its outer scope even after that outer function has finished executing. This sounds abstract, but look at the code example: createCounter returns an object with methods that still have access to the count variable, even though createCounter has already returned. The count variable is effectively private - there's no way to access it directly from outside, only through the methods provided. This pattern is incredibly useful for data privacy and encapsulation. Closures are created automatically whenever you define a function inside another function. You use closures constantly in JavaScript - every callback, every event handler that references outer variables, every function returned from another function. Understanding closures deeply is a mark of JavaScript mastery and opens up powerful patterns.">
            <div class="dark-container">
                <h2>Closures</h2>
                <p class="subtitle">Functions remember their birth scope</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">function</span> <span class="function">createCounter</span>() {
  <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// private variable</span>

  <span class="keyword">return</span> {
    increment: () => ++count,
    decrement: () => --count,
    getCount: () => count
  };
}

<span class="keyword">const</span> counter = <span class="function">createCounter</span>();
counter.<span class="function">increment</span>();  <span class="comment">// 1</span>
counter.<span class="function">increment</span>();  <span class="comment">// 2</span>
counter.<span class="function">getCount</span>();   <span class="comment">// 2</span>
<span class="comment">// count is private - can't access directly!</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 45: The this Keyword -->
        <section class="slide" id="this-keyword" data-narration="The 'this' keyword is one of JavaScript's trickiest concepts because its value depends on how a function is called, not where it's defined. When you call a method on an object like obj.greet(), 'this' refers to obj. But if you extract that method into a variable and call it standalone, 'this' becomes undefined in strict mode or the global object otherwise - the context is lost. Arrow functions behave differently - they don't have their own 'this' binding. Instead, they inherit 'this' from the enclosing scope, which is why greetArrow in the example doesn't work as expected when defined on an object. This behavior makes arrow functions perfect for callbacks where you want to preserve the outer 'this'. When 'this' isn't what you expect, check how the function is being called.">
            <div class="dark-container">
                <h2>The <code>this</code> Keyword</h2>
                <p class="subtitle">Context depends on how function is called</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> obj = {
  name: <span class="string">'Alice'</span>,
  greet() {
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Hi, I'm ${this.name}`</span>);
  },
  greetArrow: () => {
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Hi, I'm ${this.name}`</span>); <span class="comment">// undefined!</span>
  }
};

obj.<span class="function">greet</span>();       <span class="comment">// "Hi, I'm Alice"</span>
obj.<span class="function">greetArrow</span>();  <span class="comment">// "Hi, I'm undefined"</span>

<span class="keyword">const</span> fn = obj.greet;
<span class="function">fn</span>();  <span class="comment">// "Hi, I'm undefined" - lost context!</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 46: Binding this -->
        <section class="slide" id="binding-this" data-narration="When you need to control what 'this' refers to, JavaScript provides three methods: call, apply, and bind. Call invokes the function immediately with 'this' set to the first argument - additional arguments are passed individually. Apply does the same thing but takes arguments as an array - useful when you have arguments in array form already. The key difference with bind is that it doesn't invoke the function - instead, it returns a new function with 'this' permanently set. This is perfect for event handlers where you need to preserve context. In the example, boundGreet will always use person as 'this', no matter how it's called later. Modern JavaScript often uses arrow functions instead of bind for callbacks, but understanding these methods helps when working with older code or specific situations where bind is more appropriate.">
            <div class="dark-container">
                <h2>Binding <code>this</code></h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">function</span> <span class="function">greet</span>(greeting) {
  <span class="keyword">return</span> <span class="string">`${greeting}, ${this.name}`</span>;
}

<span class="keyword">const</span> person = { name: <span class="string">'Alice'</span> };

<span class="comment">// call - invoke with this + args</span>
greet.<span class="function">call</span>(person, <span class="string">'Hello'</span>);  <span class="comment">// "Hello, Alice"</span>

<span class="comment">// apply - same but args as array</span>
greet.<span class="function">apply</span>(person, [<span class="string">'Hi'</span>]);   <span class="comment">// "Hi, Alice"</span>

<span class="comment">// bind - return new function with bound this</span>
<span class="keyword">const</span> boundGreet = greet.<span class="function">bind</span>(person);
<span class="function">boundGreet</span>(<span class="string">'Hey'</span>);  <span class="comment">// "Hey, Alice"</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 47: Promises -->
        <section class="slide" id="promises" data-narration="Promises are JavaScript's way of handling asynchronous operations - things that take time like API calls, file reads, or timers. A promise represents a value that might not be available yet but will be eventually. Promises have three states: pending while the operation is in progress, fulfilled when it succeeds with a result, and rejected when it fails with an error. You create promises using the Promise constructor, which takes a function with resolve and reject callbacks. When the async operation succeeds, call resolve with the result; when it fails, call reject with the error. The then method handles success - it receives the resolved value. The catch method handles errors from anywhere in the promise chain. The finally method runs cleanup code regardless of success or failure. Promises can be chained - each then returns a new promise - which we'll see more with async/await.">
            <div class="dark-container">
                <h2>Promises</h2>
                <p class="subtitle">Handle asynchronous operations</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="function">Promise</span>((resolve, reject) => {
  <span class="comment">// async operation</span>
  <span class="keyword">if</span> (success) {
    <span class="function">resolve</span>(result);
  } <span class="keyword">else</span> {
    <span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">'Failed'</span>));
  }
});

promise
  .<span class="function">then</span>(result => <span class="function">console</span>.<span class="function">log</span>(result))
  .<span class="function">catch</span>(error => <span class="function">console</span>.<span class="function">error</span>(error))
  .<span class="function">finally</span>(() => <span class="function">console</span>.<span class="function">log</span>(<span class="string">'Done'</span>));</pre>
                </div>
            </div>
        </section>

        <!-- Slide 48: async/await -->
        <section class="slide" id="async-await" data-narration="Async/await is syntactic sugar that makes promise-based code look and behave more like synchronous code. Mark a function as async, and you can use await inside it to pause execution until a promise resolves. The code reads top to bottom like normal code, but it's actually non-blocking. In the fetchUser example, the function pauses at each await until the promise resolves, then continues with the result. Error handling with async/await uses familiar try-catch blocks instead of .catch() chains - wrap your awaits in try, and catch handles any rejected promises. Remember that async functions always return a promise, even if you return a plain value - JavaScript wraps it automatically. You can await multiple promises in parallel using Promise.all when they don't depend on each other. Async/await is now the standard way to write asynchronous JavaScript.">
            <div class="dark-container">
                <h2>async/await</h2>
                <p class="subtitle">Cleaner asynchronous code</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">async function</span> <span class="function">fetchUser</span>(id) {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">`/api/users/${id}`</span>);
    <span class="keyword">const</span> user = <span class="keyword">await</span> response.<span class="function">json</span>();
    <span class="keyword">return</span> user;
  } <span class="keyword">catch</span> (error) {
    <span class="function">console</span>.<span class="function">error</span>(<span class="string">'Failed:'</span>, error);
    <span class="keyword">throw</span> error;
  }
}

<span class="comment">// Usage</span>
<span class="keyword">const</span> user = <span class="keyword">await</span> <span class="function">fetchUser</span>(<span class="number">123</span>);</pre>
                </div>
            </div>
        </section>

        <!-- Slide 49: Fetch API -->
        <section class="slide" id="fetch-api" data-narration="The Fetch API is the modern replacement for XMLHttpRequest - it's cleaner, promise-based, and built into every browser. Call fetch with a URL to make a GET request - it returns a promise that resolves to a Response object. The response has methods like .json() to parse JSON data, .text() for plain text, and .blob() for binary data - these also return promises, so you await them too. For POST requests and other methods, pass an options object with method, headers, and body properties. The body for JSON data needs JSON.stringify to convert your object to a string. One gotcha: fetch only rejects on network errors, not HTTP errors like 404 or 500 - check response.ok or response.status to handle those. The Fetch API works great with async/await, making API calls clean and readable. You'll use fetch constantly when building data-driven applications.">
            <div class="dark-container">
                <h2>Fetch API</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// GET request</span>
<span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/data'</span>);
<span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="function">json</span>();

<span class="comment">// POST request</span>
<span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/users'</span>, {
  method: <span class="string">'POST'</span>,
  headers: {
    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>
  },
  body: <span class="function">JSON</span>.<span class="function">stringify</span>({ name: <span class="string">'Alice'</span> })
});

<span class="comment">// Check status</span>
<span class="keyword">if</span> (!response.ok) {
  <span class="keyword">throw new</span> <span class="function">Error</span>(<span class="string">`HTTP ${response.status}`</span>);
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 50: Classes -->
        <section class="slide" id="classes" data-narration="ES6 classes provide a cleaner syntax for object-oriented programming in JavaScript, though under the hood they still use prototypes. The class keyword defines a blueprint for creating objects. The constructor method runs when you create a new instance with the 'new' keyword - use it to initialize properties with 'this'. Methods defined in the class are added to the prototype, so all instances share them efficiently. Static methods belong to the class itself, not instances - call them as Person.create() rather than on an instance. Classes can also have getters and setters for computed properties. While JavaScript's class syntax looks similar to Java or C#, remember it's still prototype-based inheritance underneath. Classes make the code more familiar to developers coming from other languages and provide a clear structure for organizing related data and behavior together.">
            <div class="dark-container">
                <h2>Classes</h2>
                <p class="subtitle">ES6 syntactic sugar for prototypes</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">class</span> <span class="function">Person</span> {
  <span class="function">constructor</span>(name, age) {
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
  }

  <span class="function">greet</span>() {
    <span class="keyword">return</span> <span class="string">`Hi, I'm ${this.name}`</span>;
  }

  <span class="keyword">static</span> <span class="function">create</span>(name) {
    <span class="keyword">return new</span> <span class="function">Person</span>(name, <span class="number">0</span>);
  }
}

<span class="keyword">const</span> alice = <span class="keyword">new</span> <span class="function">Person</span>(<span class="string">'Alice'</span>, <span class="number">30</span>);
alice.<span class="function">greet</span>();  <span class="comment">// "Hi, I'm Alice"</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 51: Class Inheritance -->
        <section class="slide" id="class-inheritance" data-narration="Classes can inherit from other classes using the extends keyword, creating a parent-child relationship. In the example, Dog extends Animal - this means Dog gets all of Animal's properties and methods, plus can add its own. The super keyword is crucial: in the constructor, super(name) calls the parent's constructor to initialize inherited properties - you must call super before using 'this' in a child constructor. Methods can be overridden by defining a method with the same name in the child class - the Dog's speak method replaces Animal's. You can also call parent methods using super.methodName() if you want to extend rather than replace behavior. Inheritance creates an 'is-a' relationship: a Dog is an Animal. Use inheritance when objects truly share behavior; for just sharing code, consider composition instead. JavaScript only supports single inheritance - a class can only extend one parent.">
            <div class="dark-container">
                <h2>Class Inheritance</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">class</span> <span class="function">Animal</span> {
  <span class="function">constructor</span>(name) {
    <span class="keyword">this</span>.name = name;
  }
  <span class="function">speak</span>() {
    <span class="keyword">return</span> <span class="string">`${this.name} makes a sound`</span>;
  }
}

<span class="keyword">class</span> <span class="function">Dog</span> <span class="keyword">extends</span> <span class="function">Animal</span> {
  <span class="function">constructor</span>(name, breed) {
    <span class="keyword">super</span>(name);  <span class="comment">// call parent constructor</span>
    <span class="keyword">this</span>.breed = breed;
  }
  <span class="function">speak</span>() {
    <span class="keyword">return</span> <span class="string">`${this.name} barks!`</span>;
  }
}

<span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="function">Dog</span>(<span class="string">'Rex'</span>, <span class="string">'German Shepherd'</span>);</pre>
                </div>
            </div>
        </section>

        <!-- Slide 52: ES Modules -->
        <section class="slide" id="es-modules" data-narration="ES Modules are JavaScript's native module system for organizing code across multiple files. Use export to make variables, functions, or classes available to other files. Named exports like 'export const PI' or 'export function add' can have multiple per file - import them with curly braces. Default exports with 'export default' allow one main export per file - import without braces. You can rename imports with 'as' to avoid naming conflicts or improve clarity. Import everything from a module with 'import * as name'. Modules have their own scope - variables don't leak globally like script tags. Browsers support modules natively with type='module' on script tags, and bundlers like Vite and webpack process them for production. Modules are essential for any project beyond a single file - they let you separate concerns, reuse code, and manage dependencies clearly.">
            <div class="dark-container">
                <h2>ES Modules</h2>
                <p class="subtitle">Modern JavaScript module system</p>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div>
                        <h3>Export</h3>
                        <div class="code-block">
<pre><span class="comment">// math.js</span>
<span class="keyword">export const</span> PI = <span class="number">3.14159</span>;

<span class="keyword">export function</span> <span class="function">add</span>(a, b) {
  <span class="keyword">return</span> a + b;
}

<span class="keyword">export default class</span> <span class="function">Calculator</span> {
  <span class="comment">// ...</span>
}</pre>
                        </div>
                    </div>
                    <div>
                        <h3>Import</h3>
                        <div class="code-block">
<pre><span class="comment">// app.js</span>
<span class="keyword">import</span> Calculator <span class="keyword">from</span> <span class="string">'./math.js'</span>;
<span class="keyword">import</span> { PI, add } <span class="keyword">from</span> <span class="string">'./math.js'</span>;

<span class="comment">// Rename imports</span>
<span class="keyword">import</span> { add <span class="keyword">as</span> sum } <span class="keyword">from</span> <span class="string">'./math.js'</span>;

<span class="comment">// Import all</span>
<span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'./math.js'</span>;</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 53: Optional Chaining -->
        <section class="slide" id="optional-chaining" data-narration="Optional chaining with the question-mark-dot operator safely accesses nested properties without crashing if something in the chain is null or undefined. Before optional chaining, you'd write verbose checks like 'user && user.address && user.address.zip' to avoid errors. Now you just write 'user?.address?.zip' - if user is nullish or address is nullish, it returns undefined instead of throwing an error. This works for method calls too: 'user.getEmail?.()' calls the method only if it exists. For array access, use 'arr?.[0]' to safely get the first element. Optional chaining is especially useful when working with API responses where data structure might vary, or when accessing properties that might not exist. Combine it with nullish coalescing for providing defaults: 'user?.address?.zip ?? \"No ZIP\"'. This ES2020 feature eliminates a huge amount of defensive coding.">
            <div class="dark-container">
                <h2>Optional Chaining</h2>
                <p class="subtitle">Safe property access</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> user = {
  name: <span class="string">'Alice'</span>,
  address: {
    city: <span class="string">'Portland'</span>
  }
};

<span class="comment">// Without optional chaining</span>
<span class="keyword">const</span> zip = user && user.address && user.address.zip;

<span class="comment">// With optional chaining</span>
<span class="keyword">const</span> zip = user?.address?.zip;  <span class="comment">// undefined</span>

<span class="comment">// Also works with methods and arrays</span>
user.<span class="function">getEmail</span>?.();   <span class="comment">// undefined if method doesn't exist</span>
arr?.[<span class="number">0</span>];            <span class="comment">// undefined if arr is nullish</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 54: Nullish Coalescing -->
        <section class="slide" id="nullish-coalescing" data-narration="The nullish coalescing operator with double question marks provides default values more precisely than the logical OR operator. The problem with OR is that it triggers on any falsy value - so 'count || 10' returns 10 even when count is legitimately 0. Nullish coalescing only triggers when the left side is null or undefined, preserving intentional falsy values. 'count ?? 10' correctly returns 0 if count is 0, but returns 10 if count is null or undefined. This is huge for settings and configuration where 0, false, or empty string might be valid values you want to keep. Combine nullish coalescing with optional chaining for safe property access with defaults: 'user?.settings?.theme ?? \"dark\"'. This ES2020 feature solves a long-standing pain point in JavaScript default value handling.">
            <div class="dark-container">
                <h2>Nullish Coalescing</h2>
                <p class="subtitle">Default values done right</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Problem with || for defaults</span>
<span class="keyword">const</span> count = <span class="number">0</span>;
<span class="keyword">const</span> result = count || <span class="number">10</span>;  <span class="comment">// 10 (wrong!)</span>

<span class="comment">// ?? only triggers on null/undefined</span>
<span class="keyword">const</span> result = count ?? <span class="number">10</span>;  <span class="comment">// 0 (correct!)</span>

<span class="comment">// More examples</span>
<span class="keyword">null</span> ?? <span class="string">'default'</span>      <span class="comment">// 'default'</span>
<span class="keyword">undefined</span> ?? <span class="string">'default'</span> <span class="comment">// 'default'</span>
<span class="string">''</span> ?? <span class="string">'default'</span>        <span class="comment">// '' (empty string is not nullish)</span>
<span class="number">0</span> ?? <span class="string">'default'</span>         <span class="comment">// 0</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 55: Array Methods Deep Dive -->
        <section class="slide" id="array-methods-advanced" data-narration="Let's explore more array methods that make working with data elegant. The find method returns the first element that passes your test - perfect for looking up a user by ID or finding a specific item. Unlike filter which returns all matches in an array, find stops at the first match and returns the element itself. The some method tests if ANY element passes your condition - great for validation questions like 'does any user have admin privileges?' It returns true immediately when it finds a match. The every method tests if ALL elements pass - useful for 'are all items in stock?' or 'did all validations succeed?' It returns false immediately when any element fails. The flatMap method combines map and flat - it maps each element to an array then flattens the result one level deep. These methods, combined with map, filter, and reduce from earlier, let you write expressive data transformations without manual loops. Chain them together for complex operations.">
            <div class="dark-container">
                <h2>More Array Methods</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> users = [
  { name: <span class="string">'Alice'</span>, age: <span class="number">25</span> },
  { name: <span class="string">'Bob'</span>, age: <span class="number">30</span> },
  { name: <span class="string">'Carol'</span>, age: <span class="number">35</span> }
];

<span class="comment">// find - first match</span>
users.<span class="function">find</span>(u => u.age > <span class="number">28</span>);  <span class="comment">// { name: 'Bob', age: 30 }</span>

<span class="comment">// some - any match?</span>
users.<span class="function">some</span>(u => u.age > <span class="number">30</span>);  <span class="comment">// true</span>

<span class="comment">// every - all match?</span>
users.<span class="function">every</span>(u => u.age > <span class="number">20</span>); <span class="comment">// true</span>

<span class="comment">// flatMap - map + flatten</span>
[[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]].<span class="function">flatMap</span>(x => x); <span class="comment">// [1,2,3,4]</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 56: Set and Map -->
        <section class="slide" id="set-map" data-narration="Set and Map are ES6 data structures that solve limitations of arrays and objects. Set stores unique values only - add duplicates and they're ignored. This makes deduplication trivial: spread an array into a Set and back to an array with '[...new Set(arr)]'. Sets have add, has, delete, and size - perfect for tracking unique items like selected IDs or visited pages. Map is like an object but more powerful: keys can be any value including objects and functions, not just strings. Maps maintain insertion order when iterating, have a size property, and perform better for frequent additions and deletions. Use 'set' and 'get' methods for Map instead of bracket notation. Choose Set when you need unique values without associated data; choose Map when you need key-value pairs with non-string keys or guaranteed order. Both are iterable with for...of loops.">
            <div class="dark-container">
                <h2>Set and Map</h2>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div>
                        <h3>Set (unique values)</h3>
                        <div class="code-block">
<pre><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="function">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// Set { 1, 2, 3 }</span>

set.<span class="function">add</span>(<span class="number">4</span>);
set.<span class="function">has</span>(<span class="number">2</span>);    <span class="comment">// true</span>
set.<span class="function">delete</span>(<span class="number">1</span>);
set.size;      <span class="comment">// 3</span>

<span class="comment">// Remove duplicates</span>
[...<span class="keyword">new</span> <span class="function">Set</span>(arr)];</pre>
                        </div>
                    </div>
                    <div>
                        <h3>Map (key-value)</h3>
                        <div class="code-block">
<pre><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="function">Map</span>();

map.<span class="function">set</span>(<span class="string">'key'</span>, <span class="string">'value'</span>);
map.<span class="function">set</span>(obj, <span class="string">'data'</span>);  <span class="comment">// any key!</span>

map.<span class="function">get</span>(<span class="string">'key'</span>); <span class="comment">// 'value'</span>
map.<span class="function">has</span>(obj);   <span class="comment">// true</span>
map.size;       <span class="comment">// 2</span>

<span class="comment">// Iterate</span>
<span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> map) {}</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 57: Generators -->
        <section class="slide" id="generators" data-narration="Generators are special functions that can pause execution and resume later, producing values on demand. Define them with function* (function star) syntax, and use yield to produce values. When you call a generator, it doesn't run immediately - it returns an iterator object. Each call to .next() runs until the next yield, returning an object with the value and a done flag. When the generator finishes, done becomes true. This lazy evaluation is powerful - you can create infinite sequences without running out of memory, process large datasets piece by piece, or implement custom iteration logic. Generators work with for...of loops automatically, making them seamless to use. While you won't use generators daily, they're the foundation for async/await under the hood and useful for advanced patterns like state machines and coroutines.">
            <div class="dark-container">
                <h2>Generators</h2>
                <p class="subtitle">Pausable functions</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">function</span>* <span class="function">numberGenerator</span>() {
  <span class="keyword">yield</span> <span class="number">1</span>;
  <span class="keyword">yield</span> <span class="number">2</span>;
  <span class="keyword">yield</span> <span class="number">3</span>;
}

<span class="keyword">const</span> gen = <span class="function">numberGenerator</span>();
gen.<span class="function">next</span>();  <span class="comment">// { value: 1, done: false }</span>
gen.<span class="function">next</span>();  <span class="comment">// { value: 2, done: false }</span>
gen.<span class="function">next</span>();  <span class="comment">// { value: 3, done: false }</span>
gen.<span class="function">next</span>();  <span class="comment">// { value: undefined, done: true }</span>

<span class="comment">// Use with for...of</span>
<span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> <span class="function">numberGenerator</span>()) {
  <span class="function">console</span>.<span class="function">log</span>(num);  <span class="comment">// 1, 2, 3</span>
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 58: Proxy -->
        <section class="slide" id="proxy" data-narration="Proxy lets you intercept and customize fundamental operations on objects - it's like putting a wrapper around an object that can observe and modify behavior. Create a proxy with 'new Proxy(target, handler)' where target is the original object and handler defines traps for different operations. The get trap intercepts property access - useful for logging, validation, or returning default values for missing properties. The set trap intercepts assignment - perfect for validation, triggering updates, or tracking changes. Other traps handle delete, function calls, construction, and more. In the example, accessing or setting any property logs the action. Proxies power reactive frameworks like Vue 3 for automatically updating the UI when data changes. They're also useful for creating APIs with validation, implementing the observer pattern, or mocking objects in tests. Proxies are advanced but incredibly powerful for metaprogramming.">
            <div class="dark-container">
                <h2>Proxy</h2>
                <p class="subtitle">Intercept object operations</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> handler = {
  <span class="function">get</span>(target, prop) {
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Getting ${prop}`</span>);
    <span class="keyword">return</span> target[prop];
  },
  <span class="function">set</span>(target, prop, value) {
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Setting ${prop} = ${value}`</span>);
    target[prop] = value;
    <span class="keyword">return true</span>;
  }
};

<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="function">Proxy</span>({ name: <span class="string">'Alice'</span> }, handler);
proxy.name;        <span class="comment">// logs "Getting name", returns "Alice"</span>
proxy.age = <span class="number">30</span>;    <span class="comment">// logs "Setting age = 30"</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 59: Symbol -->
        <section class="slide" id="symbol" data-narration="Symbols are a primitive type that creates guaranteed unique identifiers. Every Symbol() call creates a new, unique value - even symbols with the same description are different. This uniqueness makes symbols perfect for object property keys where you need to avoid collisions. Library authors use symbols to add properties to user objects without risking name conflicts with user code. Symbol properties don't show up in Object.keys() or for...in loops, making them somewhat private. JavaScript also has built-in well-known symbols like Symbol.iterator that customize object behavior - implementing Symbol.iterator makes an object work with for...of loops. While you won't use symbols daily in application code, understanding them helps when you encounter them in libraries or need truly unique keys. They're another example of JavaScript providing low-level tools for advanced patterns.">
            <div class="dark-container">
                <h2>Symbol</h2>
                <p class="subtitle">Unique identifiers</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="keyword">const</span> sym1 = <span class="function">Symbol</span>(<span class="string">'description'</span>);
<span class="keyword">const</span> sym2 = <span class="function">Symbol</span>(<span class="string">'description'</span>);

sym1 === sym2  <span class="comment">// false (always unique)</span>

<span class="comment">// Use as object keys</span>
<span class="keyword">const</span> ID = <span class="function">Symbol</span>(<span class="string">'id'</span>);
<span class="keyword">const</span> obj = {
  [ID]: <span class="number">12345</span>,
  name: <span class="string">'Alice'</span>
};

obj[ID]  <span class="comment">// 12345</span>
<span class="function">Object</span>.<span class="function">keys</span>(obj)  <span class="comment">// ['name'] - symbols hidden!</span></pre>
                </div>
            </div>
        </section>

        <!-- Slide 60: Part 3 Summary -->
        <section class="slide" id="part3-summary" data-narration="Part 3 covered advanced JavaScript concepts that take time to fully master. Scope and closures enable data privacy and powerful patterns like function factories - remember that inner functions remember their outer scope even after it finishes. The 'this' keyword requires understanding execution context - it depends on how a function is called, not where it's defined. Async programming with promises and async/await makes handling network requests and time-based operations clean and readable. Classes provide familiar OOP syntax while JavaScript still uses prototypes under the hood. ES Modules let you organize code across files with import and export - essential for any real project. Modern features like optional chaining and nullish coalescing eliminate common boilerplate code. These concepts appear in every serious JavaScript codebase, so keep practicing them until they feel natural.">
            <div class="dark-container">
                <h2>Part 3 Summary</h2>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Scope &amp; Closures</h4>
                        <p>Variable access, data privacy</p>
                    </div>
                    <div class="dark-card">
                        <h4>this Keyword</h4>
                        <p>Context, binding</p>
                    </div>
                    <div class="dark-card">
                        <h4>Async JavaScript</h4>
                        <p>Promises, async/await</p>
                    </div>
                    <div class="dark-card">
                        <h4>Classes</h4>
                        <p>OOP, inheritance</p>
                    </div>
                    <div class="dark-card">
                        <h4>ES Modules</h4>
                        <p>import/export</p>
                    </div>
                    <div class="dark-card">
                        <h4>Modern Features</h4>
                        <p>?., ??, Set, Map</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== PART 4: Practical Application & Tooling ========== -->

        <!-- Part 4 Title -->
        <section class="slide title-slide" id="part4" data-narration="Part 4 covers practical tools every JavaScript developer needs: npm for packages, ESLint and Prettier for code quality, debugging techniques, and testing with Jest.">
            <h1>Part 4</h1>
            <p class="subtitle">Practical Application &amp; Tooling</p>
        </section>

        <!-- Slide 77: npm Basics -->
        <section class="slide" id="npm-basics" data-narration="npm - Node Package Manager - is the backbone of JavaScript development. It manages your project's dependencies, scripts, and configuration through a file called package.json. Use 'npm init' to create a new project, which generates this configuration file. When you need external code, 'npm install packagename' downloads it and adds it to your dependencies. The dash-D flag installs dev dependencies - tools you need for development but not production, like testing frameworks. Running 'npm install' with no arguments reads package.json and installs everything your project needs - this is how teams share projects without including the huge node_modules folder. The scripts section lets you define commands like 'npm run build' or 'npm test' that execute whatever you configure. Think of npm as your project's command center for managing code and running tasks.">
            <div class="dark-container">
                <h2>npm Basics</h2>
                <p class="subtitle">Node Package Manager</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment"># Initialize a new project</span>
npm init -y

<span class="comment"># Install dependencies</span>
npm install lodash           <span class="comment"># production dependency</span>
npm install -D typescript    <span class="comment"># dev dependency</span>

<span class="comment"># Install from package.json</span>
npm install

<span class="comment"># Run scripts</span>
npm run build
npm test
npm start</pre>
                </div>
            </div>
        </section>

        <!-- Slide 78: package.json -->
        <section class="slide" id="package-json" data-narration="package.json is your project's manifest file - it tells npm and other developers everything about your project. The name and version fields identify your package. Dependencies lists the packages your code needs to run in production, while devDependencies lists tools needed only for development like TypeScript, ESLint, and testing frameworks. The caret symbol in version numbers means 'compatible with' - npm will install newer minor versions but not major ones that might break things. The scripts section is incredibly powerful - you define custom commands that run with 'npm run scriptname'. Common scripts include dev for starting a development server, build for creating production bundles, test for running tests, and lint for checking code quality. When you clone a project, package.json tells you exactly what to install and how to run it.">
            <div class="dark-container">
                <h2>package.json</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre>{
  <span class="string">"name"</span>: <span class="string">"my-project"</span>,
  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,
  <span class="string">"scripts"</span>: {
    <span class="string">"dev"</span>: <span class="string">"vite"</span>,
    <span class="string">"build"</span>: <span class="string">"tsc && vite build"</span>,
    <span class="string">"test"</span>: <span class="string">"jest"</span>,
    <span class="string">"lint"</span>: <span class="string">"eslint src/"</span>
  },
  <span class="string">"dependencies"</span>: {
    <span class="string">"react"</span>: <span class="string">"^19.0.0"</span>
  },
  <span class="string">"devDependencies"</span>: {
    <span class="string">"typescript"</span>: <span class="string">"^5.0.0"</span>,
    <span class="string">"eslint"</span>: <span class="string">"^9.0.0"</span>
  }
}</pre>
                </div>
            </div>
        </section>

        <!-- Slide 79: ESLint -->
        <section class="slide" id="eslint" data-narration="ESLint is a static analysis tool that finds problems in your JavaScript code before you even run it. It catches unused variables, undefined references, syntax errors, and common mistakes that lead to bugs. Beyond error detection, ESLint enforces coding standards - you can require semicolons, enforce naming conventions, or ban certain patterns your team considers problematic. The init command walks you through creating a configuration file where you specify your rules. ESLint 9 introduced flat config as the default configuration format, using eslint.config.js instead of the older .eslintrc files. Flat config is simpler, more explicit, and uses standard JavaScript imports. Running ESLint with the --fix flag automatically fixes many issues like adding missing semicolons or removing unused imports. Most teams integrate ESLint into their editor for real-time feedback and into their CI pipeline to block merging code that doesn't pass. The time invested in setting up ESLint pays off massively in prevented bugs and consistent code style across your team.">
            <div class="dark-container">
                <h2>ESLint</h2>
                <p class="subtitle">Find and fix code problems</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment"># Install</span>
npm install -D eslint

<span class="comment"># Initialize config</span>
npm init @eslint/config

<span class="comment"># Run linting</span>
npx eslint src/
npx eslint src/ --fix  <span class="comment"># auto-fix issues</span></pre>
                </div>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div class="dark-card">
                        <h4>Catches</h4>
                        <p>Unused variables, undefined refs, syntax errors</p>
                    </div>
                    <div class="dark-card">
                        <h4>Enforces</h4>
                        <p>Consistent style, best practices</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 80: Prettier -->
        <section class="slide" id="prettier" data-narration="Prettier is an opinionated code formatter, and when we say opinionated, we mean it makes most formatting decisions for you. You don't get to argue about whether to use tabs or spaces, where to break long lines, or how to indent nested objects - Prettier decides, and honestly that's a good thing. It eliminates formatting debates entirely so your team can focus on actual code logic. Now, how does Prettier differ from ESLint? ESLint catches bugs and enforces code quality rules like no unused variables or no implicit globals. Prettier only handles formatting - indentation, spacing, line breaks, semicolons, quote style. They complement each other perfectly, and most projects use both together. The best workflow is enabling format-on-save in your editor - every time you hit save, Prettier automatically reformats your file. It's like having a tidy-up robot that runs instantly. To configure Prettier, create a .prettierrc file in your project root with your preferences for things like single vs double quotes, semicolons, tab width, and trailing commas. You can also add a .prettierignore file to skip generated files or build output. Once your team agrees on a Prettier config, commit it to the repo and formatting becomes completely automatic and consistent across everyone's machines.">
            <div class="dark-container">
                <h2>Prettier</h2>
                <p class="subtitle">Opinionated code formatter</p>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment"># Install</span>
npm install -D prettier

<span class="comment"># Format files</span>
npx prettier --write src/

<span class="comment"># .prettierrc config</span>
{
  <span class="string">"semi"</span>: <span class="keyword">true</span>,
  <span class="string">"singleQuote"</span>: <span class="keyword">true</span>,
  <span class="string">"tabWidth"</span>: <span class="number">2</span>,
  <span class="string">"trailingComma"</span>: <span class="string">"es5"</span>
}</pre>
                </div>
                <p style="margin-top: 1rem; color: #2dd4bf;">Tip: Enable format-on-save in your IDE</p>
            </div>
        </section>

        <!-- Slide 81: Debugging -->
        <section class="slide" id="debugging" data-narration="Effective debugging separates productive developers from frustrated ones. Browser DevTools - opened with F12 - are your best friend. The Sources tab lets you set breakpoints by clicking line numbers - execution pauses there so you can inspect variable values and step through code line by line. The Console tab lets you run JavaScript directly and see your console.log output. The Network tab shows all HTTP requests - essential for debugging API calls. In your code, the debugger statement acts like a breakpoint - execution pauses when it hits that line if DevTools is open. Instead of just console.log, try logging objects like console.log({ user, data }) to see variable names with their values. The console.trace() method shows you the call stack - how you got to this point in the code. Learning to debug efficiently will save you countless hours of frustration.">
            <div class="dark-container">
                <h2>Debugging Techniques</h2>
                <div class="dark-two-column" style="margin-top: 1rem;">
                    <div>
                        <h3>Browser DevTools</h3>
                        <ul>
                            <li><strong>F12</strong> - Open DevTools</li>
                            <li><strong>Sources tab</strong> - Set breakpoints</li>
                            <li><strong>Console tab</strong> - Run JS</li>
                            <li><strong>Network tab</strong> - HTTP requests</li>
                        </ul>
                    </div>
                    <div>
                        <h3>In Code</h3>
                        <div class="code-block">
<pre><span class="comment">// Pause execution</span>
<span class="keyword">debugger</span>;

<span class="comment">// Log with context</span>
<span class="function">console</span>.<span class="function">log</span>({ user, data });

<span class="comment">// Trace call stack</span>
<span class="function">console</span>.<span class="function">trace</span>();</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 82: Testing with Jest -->
        <section class="slide" id="jest-basics" data-narration="Jest is a testing framework that makes writing tests straightforward and even enjoyable. Tests ensure your code works correctly and, more importantly, that it keeps working when you make changes. The describe function groups related tests together, while test or it defines individual test cases. Inside each test, you use expect with matchers to assert what should happen - expect(add(2, 3)).toBe(5) checks that your add function returns 5. When tests pass, you get a green checkmark; when they fail, Jest tells you exactly what went wrong and where. Jest also includes mocking capabilities for isolating code from its dependencies, and snapshot testing for UI components. Running 'npm test' executes all your test files. Start by testing your most critical functions first, then expand coverage over time. Tests are an investment that prevents regression bugs.">
            <div class="dark-container">
                <h2>Testing with Jest</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// math.test.js</span>
<span class="keyword">import</span> { add, multiply } <span class="keyword">from</span> <span class="string">'./math'</span>;

<span class="function">describe</span>(<span class="string">'math functions'</span>, () => {
  <span class="function">test</span>(<span class="string">'adds two numbers'</span>, () => {
    <span class="function">expect</span>(<span class="function">add</span>(<span class="number">2</span>, <span class="number">3</span>)).<span class="function">toBe</span>(<span class="number">5</span>);
  });

  <span class="function">test</span>(<span class="string">'multiplies two numbers'</span>, () => {
    <span class="function">expect</span>(<span class="function">multiply</span>(<span class="number">2</span>, <span class="number">3</span>)).<span class="function">toBe</span>(<span class="number">6</span>);
  });
});

<span class="comment"># Run tests</span>
npm test</pre>
                </div>
            </div>
        </section>

        <!-- Slide 83: Jest Matchers -->
        <section class="slide" id="jest-matchers" data-narration="Jest provides a rich set of matchers for different assertion types, and using the right one makes your tests clearer. Use toBe for primitive values like numbers and strings - it uses strict equality. For objects and arrays, use toEqual which does deep comparison of all properties. Truthiness matchers like toBeTruthy, toBeFalsy, toBeNull, and toBeUndefined check boolean contexts. Number matchers like toBeGreaterThan and toBeCloseTo handle numeric comparisons - toBeCloseTo is essential for floating-point math where 0.1 + 0.2 doesn't exactly equal 0.3. For arrays and strings, toContain checks membership while toMatch tests against regular expressions. The toThrow matcher verifies that a function throws an error - wrap the function call in an arrow function so Jest can catch the error. Choosing descriptive matchers makes test failures easier to understand.">
            <div class="dark-container">
                <h2>Jest Matchers</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Equality</span>
<span class="function">expect</span>(value).<span class="function">toBe</span>(<span class="number">5</span>);           <span class="comment">// strict equality</span>
<span class="function">expect</span>(obj).<span class="function">toEqual</span>({ a: <span class="number">1</span> });  <span class="comment">// deep equality</span>

<span class="comment">// Truthiness</span>
<span class="function">expect</span>(value).<span class="function">toBeTruthy</span>();
<span class="function">expect</span>(value).<span class="function">toBeFalsy</span>();
<span class="function">expect</span>(value).<span class="function">toBeNull</span>();

<span class="comment">// Numbers</span>
<span class="function">expect</span>(num).<span class="function">toBeGreaterThan</span>(<span class="number">3</span>);
<span class="function">expect</span>(num).<span class="function">toBeCloseTo</span>(<span class="number">0.3</span>);

<span class="comment">// Arrays/Strings</span>
<span class="function">expect</span>(arr).<span class="function">toContain</span>(<span class="string">'item'</span>);
<span class="function">expect</span>(str).<span class="function">toMatch</span>(<span class="string">/pattern/</span>);

<span class="comment">// Errors</span>
<span class="function">expect</span>(() => <span class="function">fn</span>()).<span class="function">toThrow</span>(<span class="string">'error'</span>);</pre>
                </div>
            </div>
        </section>

        <!-- Slide 84: Async Testing -->
        <section class="slide" id="async-testing" data-narration="Testing asynchronous code requires special handling because Jest needs to know when your async operations complete. The cleanest approach is making your test function async and using await - Jest automatically waits for the promise to resolve. If you're testing that a promise resolves to a specific value, the resolves matcher reads nicely: expect(fetchData()).resolves.toBe('data'). Similarly, rejects checks that a promise rejects: expect(failingFn()).rejects.toThrow(). Remember to return or await your promise - forgetting this is a common mistake that causes tests to pass incorrectly because Jest doesn't wait for the assertion. For callback-style async code, Jest provides a done parameter you call when the test finishes. When testing code that makes real API calls, you'll usually want to mock those calls for speed and reliability - we'll cover mocking in more advanced testing topics.">
            <div class="dark-container">
                <h2>Testing Async Code</h2>
                <div class="code-block" style="margin-top: 1rem;">
<pre><span class="comment">// Async/await</span>
<span class="function">test</span>(<span class="string">'fetches user data'</span>, <span class="keyword">async</span> () => {
  <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="function">fetchUser</span>(<span class="number">1</span>);
  <span class="function">expect</span>(user.name).<span class="function">toBe</span>(<span class="string">'Alice'</span>);
});

<span class="comment">// With resolves/rejects</span>
<span class="function">test</span>(<span class="string">'promise resolves'</span>, () => {
  <span class="keyword">return</span> <span class="function">expect</span>(<span class="function">fetchData</span>()).<span class="function">resolves</span>.<span class="function">toBe</span>(<span class="string">'data'</span>);
});

<span class="function">test</span>(<span class="string">'promise rejects'</span>, () => {
  <span class="keyword">return</span> <span class="function">expect</span>(<span class="function">failingFn</span>()).<span class="function">rejects</span>.<span class="function">toThrow</span>();
});</pre>
                </div>
            </div>
        </section>

        <!-- Part 4 Summary -->
        <section class="slide" id="part4-summary" data-narration="Part 4 covered the practical tools that professional JavaScript developers use daily. npm manages your packages and project scripts through package.json - it's the command center for your project. ESLint catches bugs and enforces code standards before they reach production. Prettier automatically formats your code so your team never argues about tabs versus spaces again. Browser DevTools and debugging techniques help you find and fix problems efficiently. Jest provides a complete testing solution with a great developer experience. These tools form the modern JavaScript development workflow: write code, lint it, format it, test it, build it, deploy it. Setting up this toolchain properly at the start of a project saves enormous time over its lifetime. Make these tools part of your daily practice.">
            <div class="dark-container">
                <h2>Part 4 Summary</h2>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>npm</h4>
                        <p>Package management, scripts</p>
                    </div>
                    <div class="dark-card">
                        <h4>ESLint</h4>
                        <p>Find code problems</p>
                    </div>
                    <div class="dark-card">
                        <h4>Prettier</h4>
                        <p>Consistent formatting</p>
                    </div>
                    <div class="dark-card">
                        <h4>Debugging</h4>
                        <p>DevTools, breakpoints</p>
                    </div>
                    <div class="dark-card">
                        <h4>Jest</h4>
                        <p>Unit testing framework</p>
                    </div>
                    <div class="dark-card">
                        <h4>Best Practices</h4>
                        <p>Lint, format, test!</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ========== PART 5: Assignment ========== -->

        <!-- Part 5 Title -->
        <section class="slide title-slide" id="part5" data-narration="Part 5 contains your assignment for this module. You'll complete a JavaScript tutorial and quiz to demonstrate your understanding.">
            <h1>Part 5</h1>
            <p class="subtitle">Assignment</p>
        </section>

        <!-- Assignment -->
        <section class="slide" id="assignment" data-narration="For this module's assignment, you need to complete the W3Schools JavaScript tutorial and then take the JavaScript quiz. Take a screenshot of your completed quiz results and submit it to Canvas.">
            <div class="dark-container">
                <h2>Module 3 Assignment</h2>
                <p class="subtitle">Complete the following steps</p>
                <div class="feature-grid" style="margin-top: 1.5rem;">
                    <div class="feature-item">
                        <span class="feature-icon" style="font-size: 2rem;">1</span>
                        <div class="feature-text">
                            <strong>Complete the W3Schools JavaScript Tutorial</strong>
                            Work through the tutorial to learn JavaScript fundamentals
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon" style="font-size: 2rem;">2</span>
                        <div class="feature-text">
                            <strong>Take the JavaScript Quiz</strong>
                            Test your knowledge with the W3Schools quiz
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon" style="font-size: 2rem;">3</span>
                        <div class="feature-text">
                            <strong>Screenshot Your Results</strong>
                            Capture a screenshot showing your quiz score
                        </div>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon" style="font-size: 2rem;">4</span>
                        <div class="feature-text">
                            <strong>Submit to Canvas</strong>
                            Upload your screenshot to the Module 3 assignment
                        </div>
                    </div>
                </div>
                <div style="margin-top: 2rem; text-align: center; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <a href="https://www.w3schools.com/js/default.asp" target="_blank" rel="noopener" style="display: inline-block; background: #3d4a5d; color: #fff; padding: 1rem 2rem; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 1.1rem; transition: background 0.2s ease;">Start the Tutorial</a>
                    <a href="https://www.w3schools.com/js/js_quiz.asp" target="_blank" rel="noopener" style="display: inline-block; background: #2dd4bf; color: #1a2332; padding: 1rem 2rem; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 1.1rem; transition: background 0.2s ease;">Take the JavaScript Quiz</a>
                </div>
            </div>
        </section>

        <!-- Additional Resources -->
        <section class="slide" id="resources" data-narration="Here are some additional resources to help you continue learning JavaScript. These include documentation, tutorials, and practice exercises.">
            <div class="dark-container">
                <h2>Additional Resources</h2>
                <p class="subtitle">Continue your JavaScript learning journey</p>
                <ul class="resource-list">
                    <li>
                        <a href="https://www.linkedin.com/learning/javascript-essential-training" target="_blank" rel="noopener" class="resource-link">
                            <span class="resource-icon">in</span>
                            <div class="resource-info">
                                <h4>JavaScript Essential Training</h4>
                                <p>Comprehensive video course on LinkedIn Learning</p>
                            </div>
                        </a>
                    </li>
                    <li>
                        <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener" class="resource-link">
                            <span class="resource-icon">MDN</span>
                            <div class="resource-info">
                                <h4>MDN: Adding Interactivity</h4>
                                <p>Mozilla's guide to making websites interactive with JavaScript</p>
                            </div>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.w3schools.com/js/default.asp" target="_blank" rel="noopener" class="resource-link">
                            <span class="resource-icon">W3</span>
                            <div class="resource-info">
                                <h4>W3Schools JavaScript Tutorial</h4>
                                <p>Step-by-step JavaScript tutorial with examples</p>
                            </div>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.w3schools.com/js/js_exercises.asp" target="_blank" rel="noopener" class="resource-link">
                            <span class="resource-icon">W3</span>
                            <div class="resource-info">
                                <h4>W3Schools JavaScript Exercises</h4>
                                <p>Practice exercises to test your JavaScript skills</p>
                            </div>
                        </a>
                    </li>
                </ul>
            </div>
        </section>

        <!-- Module Summary -->
        <section class="slide" id="module-summary" data-narration="Congratulations on completing Module 3! You've learned JavaScript from its history through modern features, practical tooling, and hands-on exercises. Keep practicing!">
            <div class="dark-container">
                <h2>Module 3 Complete!</h2>
                <p class="subtitle">What you've learned</p>
                <div class="dark-three-column" style="margin-top: 1.5rem;">
                    <div class="dark-card">
                        <h4>Part 1</h4>
                        <p>JS History &amp; Origins</p>
                    </div>
                    <div class="dark-card">
                        <h4>Part 2</h4>
                        <p>JS Fundamentals</p>
                    </div>
                    <div class="dark-card">
                        <h4>Part 3</h4>
                        <p>Advanced JavaScript</p>
                    </div>
                    <div class="dark-card">
                        <h4>Part 4</h4>
                        <p>Tooling &amp; Testing</p>
                    </div>
                    <div class="dark-card">
                        <h4>Part 5</h4>
                        <p>Assignment</p>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 1.5rem; color: #2dd4bf; font-size: 1.2rem;">Keep building, keep learning!</p>
            </div>
        </section>

    </div>

    <script src="../js/slides.js"></script>
</body>
</html>
